<html>
    <head>
        <style>
            img {
                display: none;
            }
            canvas {
                -ms-interpolation-mode: nearest-neighbor;
                image-rendering: -webkit-optimize-contrast;
                image-rendering: -webkit-crisp-edges;
                image-rendering: -moz-crisp-edges;
                image-rendering: -o-crisp-edges;
                image-rendering: pixelated;
                /*width: 100%;
                height: auto;*/
            }
            html, body {
                margin: 0;
            }
            #f {
                width: 70px;
                height: 70px;
                position: absolute;
                background-color: black;
                top: 480px;
            }
            #game {
                position: absolute;
                width: 480px;
                height: 480px;
                display: block;
                overflow: hidden;
            }
            #game *{
                position: absolute;
                top:0;
                left: 0;
                display: block;
                margin: auto;
            }
        </style>
    </head>
    <body>
        <div id="f"></div>
        <div id="game"></div>
    </body>
    <!--Javascript code starts here !-->
    <script>
    	/* Engine Constants */
    	/* Pallet */
        const COLORS = ["#332c50","#46878f","#94e344","#e2f3e4"];
        /* FX */
        const CIRCLE_TRANSITION = 0x0001;
        const FADE = 0x0010;
        const FLASH = 0x0100;
        /* States */
        const GAME_STATE = 1;
        const MENU_STATE = 2;
        /* Game Size */
        const WIDTH = 480;
        const HEIGHT = 480;

        let fullscreen = false;
        window.onload = () => {
            /* Game div */
            let _gameDiv = document.getElementById("game");
            /* Background layer */
            let _bgCanvas = _gameDiv.appendChild(document.createElement("CANVAS"));
            _bgCanvas.width = WIDTH;
            _bgCanvas.height = HEIGHT;
            let _bgCtx = _bgCanvas.getContext("2d");
            /*Pixel Perfect*/
            _bgCtx.imageSmoothingEnabled = false;
            /*Scale up game*/
            _bgCtx.scale(2,2);
            /* Foreground layer */
            let _canvas = _gameDiv.appendChild(document.createElement("CANVAS"));
            _canvas.width = WIDTH;
            _canvas.height = HEIGHT;
            let _ctx = _canvas.getContext("2d");
            /*Pixel Perfect*/
            _ctx.imageSmoothingEnabled = false;
            /*Scale up game*/
            _ctx.scale(2,2);

            /* Assign graphics their own variable */
            let graphics = document.getElementById("g");

            let objects = [];
            let objId = 0;
            let mouse = {x:0,y:0,down:false,click:false};
            let deltaTime = Date.now();
            let frames = 0;
            let fps = 60;
            let debug = true;
            let fx = {};
            let sineOffset = 0;

            /* Game variables */
            let groups;
            let enemyGroups;
            let whichEnemy;
            let movingGroup;
            let message;
            let buildings;
            let bMActive;
            let turn;
            let attackGroup;
            let targetedSprite;
            let gameState;
            let level;

            /* Objects */
            const GameObject = (x,y) => {
                let state = {
                  x,
                  y,
                  zIndex: 0,
                  ID: 0,
                  draw: () => {},
                  update: () => {},
                }
                return state;
            };

            const Troop = (x,y,frame) => {
                /* Have troop extend GameObject */
                let state = Object.assign(
                  GameObject(x,y),
                  {
                    zIndex: 1,
                    frame,
                    group: 1,
                    goto: null,
                    draw: () => {
                      _ctx.drawImage(graphics,state.frame*16,0,16,16,state.x,state.y,16,16);
                    },
                    update: () => {
                      if (state.goto != null) {
                          state.x += Math.floor(state.goto[0] - state.x)/3;
                          state.y += Math.floor(state.goto[1] - state.y)/3;
                          if (state.x == state.goto[0] && state.y == state.goto[1])
                              state.goto = null;
                      }
                    },
                  },
                );

                return state;
            };
            /* Building ideas:
            Attack tower
            Make more guys building
            Wall to stall for time
            */
            const Building = (x,y,type) => {
                /* Combine objects */
                let state = Object.assign(
                  GameObject(x,y),
                  {
                    mpBuild: 10,
                    actionStatus: "start",
                    zIndex: 1,
                    type,
                    draw: () => {
                      if (state.type = "t") {
                          _ctx.drawImage(graphics,16,16,32,16,state.x,state.y,32,16);
                          _ctx.drawImage(graphics,48,16,32,16,state.x,state.y+16,32,16);
                          state.mpBuild = 10;
                      }
                    },
                    action: () => {
                      /* Cancel request if action is already in progress */
                      if (state.actionStatus == "progress" || state.actionStatus == "complete")
                          return;

                      state.actionStatus = "progress";
                      targetSprite(state,1000,() => {
                        if (state.type == "t") {
                          let range = 30;
                          for (let i=0; i < enemyGroups.length; i++) {
                              if (Math.sqrt(Math.pow(enemyGroups[i].x - state.x,2)+Math.pow(enemyGroups[i].y - state.y,2)) < range) {
                                  enemyGroups[i].members.splice(0,Math.ceil(enemyGroups[i].members.length/10));
                              }
                          }
                          state.actionStatus = "complete";
                        }
                      });
                    },
                    kill: () => {
                      for (let i=0;i<buildings.length;i++)
                        if (buildings[i].ID == state.ID)
                          buildings.splice(i,1);
                      remove(state);
                    },
                  }
                );
                return state;
            };

            const BuildingMenu = (group) => {
              /* Menu's variables */
                let items = ["t","t","t","t","t","t"];
                let descriptions = [
                  "Attack Tower\n[10 MP]\nProvide assualt\nwithout risk at\nthe cost of MP."
                ];

                let state = Object.assign(
                  GameObject(0,0),
                  {
                    zIndex: 100,
                    dummyBuildings: [],
                    hover: null,
                    draw: () => {
                      state.update();
                      _ctx.textAlign = "center";
                      _ctx.strokeStyle = COLORS[0];
                      _ctx.lineWidth = 10;
                      _ctx.fillStyle = COLORS[3];
                      _ctx.beginPath();
                      _ctx.rect(0,0,240,240);
                      _ctx.fill();
                      _ctx.stroke();
                      _ctx.lineWidth = 2;
                      _ctx.fillStyle = COLORS[1];
                      _ctx.font = "bold 18px Arial"
                      _ctx.fillText("Building Menu",120,24);
                      _ctx.font = "bold 6px Arial"
                      for (let i=0;i<items.length;i++) {
                          state.dummyBuildings[i].draw();
                          if (descriptions[i]) {
                              _ctx.fillStyle = COLORS[1];
                              let text = descriptions[i].split("\n");
                              for (let t=0;t<text.length;t++) {
                                 if (t==0)
                                     _ctx.font = "bold 7px Arial";
                                  else
                                     _ctx.font = "bold 6px Arial";
                                  _ctx.fillText(text[t],state.dummyBuildings[i].x+16,state.dummyBuildings[i].y + 40 + 10*t);
                              }
                          }
                      }
                      /* Back Button */
                      _ctx.drawImage(graphics,80,16,16,16,14,10,16,16);
                      /* Flavor text */
                      _ctx.fillText("Group's MP: " + group.members.length,120,230);
                      _ctx.textAlign = "left";
                      if (state.hover != null) {
                          _ctx.beginPath();
                          _ctx.rect(state.hover.x-11,state.hover.y-5,56,90);
                          _ctx.stroke();
                      }
                    },
                    update: () => {
                      bMActive = true;
                      /* Check mouse position around each time and draw
                      a rectangle around it if selected */
                      state.hover = null;
                      if (state.dummyBuildings)
                      for (var i=0;i<state.dummyBuildings.length;i++) {
                          if (mouse.x > state.dummyBuildings[i].x-10 && mouse.x < state.dummyBuildings[i].x + 42 && mouse.y > state.dummyBuildings[i].y-5 && mouse.y < state.dummyBuildings[i].y + 85) {
                              state.hover = {x:state.dummyBuildings[i].x,y:state.dummyBuildings[i].y};
                              /* If clicked place build */
                              if (mouse.click && group.members.length >= state.dummyBuildings[i].mpBuild) {
                                  mouse.click = false;
                                  group.actions -= 1;
                                  /* Not to be confused with state.dummyBuildings (this is the global array) */
                                  buildings.push(add(Building(group.x - 8,group.y,state.dummyBuildings[i].type)));
                                  group.goto = [group.x,group.y + 46];
                                  state.close();
                              }
                          }
                      }
                      /* Close menu if click on back button */
                      if (mouse.x > 14 && mouse.x < 30 && mouse.y > 10 && mouse.y < 26 && mouse.click) {
                          state.close();
                      }
                    },
                    close: () => {
                      for (let i=0;i<state.dummyBuildings.length;i++) {
                          remove(state.dummyBuildings[i]);
                      }
                      remove(state);
                      bMActive = false;
                    },
                  }
                );

                /* Add building sprites to dummyBuildings array */
                for (let i=0;i<items.length;i++) {
                    state.dummyBuildings.push(add(Building(20+55*(i%4),90*(Math.floor(i/4)+1) - 50,items[i])));
                }

                return state;
            };

            const Group = (x,y,enemy) => {
                let state = Object.assign(
                  GameObject(x,y),
                  {
                    zIndex: 3,
                    range: [x,y,16],
                    enemy: false,
                    members: [],
                    group: "A",
                    goto: null,
                    list: null,
                    rangeAngle: 0,
                    actions: 2,
                    draw: () => {
                      state.update();
                      for (let i=0;i<state.members.length;i++){
                          state.members[i].update();
                          state.members[i].x += state.x;
                          state.members[i].y += state.y;
                          state.members[i].draw();
                          state.members[i].x -= state.x;
                          state.members[i].y -= state.y;
                      }
                      _ctx.lineWidth = 2;
                      if (enemy == true) {
                          _ctx.beginPath();
                          _ctx.strokeStyle = COLORS[0];
                          _ctx.rect(state.x-12,state.y-12,40,40);
                          _ctx.stroke();
                          /*Group info*/
                          _ctx.beginPath();
                          _ctx.fillStyle = COLORS[0];
                          _ctx.rect(state.x + 16,state.y + 19,12,10);
                          _ctx.fill();
                          /*Info text*/
                          _ctx.fillStyle = COLORS[3];
                          _ctx.font = "bold 8px Arial"
                          _ctx.fillText(state.members.length,state.x + 17,state.y + 26.5);
                      } else {
                          /*Circle around group*/
                          _ctx.beginPath();
                          _ctx.strokeStyle = COLORS[0];
                          _ctx.arc(state.x+8,state.y+8,24,0,Math.PI*2);
                          _ctx.stroke();
                          /*Group info*/
                          _ctx.beginPath();
                          _ctx.fillStyle = COLORS[0];
                          _ctx.rect(state.x + 6,state.y + 22,30,10);
                          _ctx.fill();
                          /* Action counter */
                          _ctx.beginPath();
                          _ctx.arc(state.x - 10,state.y - 10,5,0,Math.PI*2);
                          _ctx.fill();
                          /*Info text*/
                          _ctx.fillStyle = COLORS[3];
                          _ctx.font = "bold 8px Arial"
                          _ctx.fillText(state.group + ": " + state.members.length,state.x + 6.5,state.y + 30);
                          _ctx.fillText(state.actions,state.x-12.75,state.y-7);
                      }
                    },
                    update: () => {
                      if (movingGroup == null) {
                              state.range = [state.x,state.y,32+ Math.log(state.members.length)*16]
                      }
                      if (mouse.click == true && mouse.x > state.x - 20 && mouse.x < state.x + 32 && mouse.y > state.y - 20 && mouse.y < state.y + 32) {
                          if (enemy != true) {
                              /* Create action command list */
                              if (state.list == null && movingGroup == null && state.actions > 0 && message == false && bMActive == false && attackGroup == null && !fx.type) {
                                  /* Delete all other group's lists, but be sure the group exists first.*/
                                  for (let i=0;i<groups.length;i++) {
                                      if (groups[i].list != null && groups[i].list.active == -1) {
                                          remove(groups[i].list);
                                          groups[i].list = null;
                                      }
                                      if (groups[i].list != null && groups[i].list.active != -1)
                                          return;
                                  }
                                  /* Disable click */
                                  mouse.click = false;
                                  state.list = add(List(mouse.x - 5,mouse.y - 5,state));
                              }
                          } else {
                              /* For enemy groups only */
                              if (attackGroup != null) {
                                  /* Initiate attack */
                                  let distance = Math.sqrt(Math.pow((state.x - attackGroup.x),2)+Math.pow((state.y - attackGroup.y),2));
                                  if (distance < 48) {
                                      enemyLength = state.members.length;
                                      state.members.splice(0,attackGroup.members.length);
                                      attackGroup.actions -= 1;
                                      /* Attacking group also takes loses */
                                      attackGroup.members.splice(0,enemyLength/2);
                                      shuffleGroup(attackGroup,12);
                                      shuffleGroup(state,12);
                                      attackGroup = null;
                                  }
                              }
                          }
                      }
                      /* Delete dead groups */
                      if (state.members.length < 1){
                          remove(state);
                          if (state.enemy == true) {
                              for (let i=0;i<enemyGroups.length;i++) {
                                  if (enemyGroups[i].ID == state.ID)
                                      enemyGroups.splice(i,1);
                              }
                          } else {
                              for (let i=0;i<groups.length;i++) {
                                  if (groups[i].ID == state.ID)
                                      groups.splice(i,1);
                              }
                          }
                      }
                      if (state.goto != null) {
                          state.x += (state.goto[0] - state.x)/3;
                          state.y += (state.goto[1] - state.y)/3;
                          if (Math.round(state.x) == Math.round(state.goto[0]) && Math.round(state.y) == Math.round(state.goto[1]))
                              state.goto = null;
                      }
                      if (state.enemy == false) {
                          if (state.x > 240)
                              state.goto = [220,state.y];
                          else if (state.x < 0)
                              state.goto = [20,state.y];
                          if (state.y > 240)
                              state.goto = [state.x,220];
                          else if (state.y < 0)
                              state.goto = [state.x,20];
                      }
                    },
                    split: () => {
                      let newGroup;
                      if (state.members.length < 2)
                          return;
                      /*Split the group, reposition and shuffle it*/
                      if (enemy == true) {
                          newGroup = shuffleGroup(pushGroup(state.x, state.y,true),12);
                      } else {
                          if (groups.length >= 4)
                              return;
                         newGroup = shuffleGroup(pushGroup(state.x, state.y),12);
                      }
                      newGroup.members = state.members.splice(state.members.length/2,state.members.length/2);
                      newGroup.goto = [state.x - 26, state.y];
                      state.goto = [state.x + 26,state.y]
                      shuffleGroup(state,12);
                      /* This code used to make splitting count as one action, now it does not*/
                      /*state.actions -= 1;*/
                      newGroup.actions = state.actions;
                    },
                });

                /* Enemy status */
                if (enemy) {
                    state.enemy = enemy;
                    state.zIndex = 2;
                }

                return state;
            };

            const List = (x,y,group) => {
                let state = Object.assign(
                  GameObject(x,y),
                  {
                    zIndex: 99,
                    items: ["Split","Move","Build","Attack","Rest"],
                    active: null,
                    group,
                    inactive: [0,0,0,0,0],
                    draw: () => {
                      state.update();
                      _ctx.beginPath();
                      _ctx.fillStyle = COLORS[0];
                      _ctx.rect(state.x,state.y,50,70);
                      _ctx.fill();
                      if (state.active != -1 && state.inactive[state.active] == 0) {
                          _ctx.beginPath();
                          _ctx.fillStyle = COLORS[1];
                          _ctx.rect(state.x,state.y + state.active*(70/5),50,70/5);
                          _ctx.fill();
                      }
                      _ctx.fillStyle = COLORS[3];
                      _ctx.font = "bold 11px Arial"
                      for (let i=0;i<state.items.length;i++) {
                          if (state.inactive[i] == 1) {
                             _ctx.fillStyle = COLORS[1];
                          }
                          _ctx.fillText(state.items[i],state.x + 2,state.y + (70/5) * i + 11);
                          if (state.inactive[i] == 1) {
                             _ctx.fillStyle = COLORS[3];
                          }
                      }
                    },
                    update: () => {
                      if (mouse.x > state.x && mouse.x < state.x + 50 && mouse.y > state.y && mouse.y < state.y + 70) {
                          state.active = Math.floor((mouse.y - state.y) / (70/5));
                      } else {
                          state.active = -1;
                      }
                      if (mouse.click) {
                          mouse.click = false;
                          if (state.inactive[state.active] == 0) {
                              if (state.active == 0) {
                                  state.group.split();
                              } else if (state.active == 1) {
                                  movingGroup = group;
                              } else if (state.active == 2) {
                                  add(BuildingMenu(state.group));
                              } else if (state.active == 3) {
                                  attackGroup = group;
                              } else if (state.active == 4) {
                                  state.group.actions = 0;
                              }
                          }
                          /* List is removed whether action occurs or not
                          Unless it is an inactive item
                          */
                          if (state.inactive[state.active] == 0 || state.active == -1) {
                              remove(state);
                              state.group.list = null;
                          }
                      }
                    }
                  }
                );

                /* If list is off screen, move it */
                if (state.x + 50 > 240) {
                    state.x -= 40;
                }
                if (state.y + 70 > 240) {
                    state.y -= 60;
                }

                let distances = [];
                let target = 0;
                /* disable attack if no enemies are nearby */
                for (let i=0; i < enemyGroups.length; i++) {
                    distances[i] = Math.sqrt(Math.pow(enemyGroups[i].x - group.x,2)+Math.pow(enemyGroups[i].y - group.y,2));
                    if (distances[i-1] && distances[i] < distances[i-1])
                        target = i;
                }
                if (distances[target] > 48) {
                    state.inactive[3] = 1;
                }
                /* Disable split if there are more than four groups*/
                if (groups.length >= 4)
                    state.inactive[0] = 1;

                return state;
            };

            const Message = (text,y,length,callBack) => {
                let state = Object.assign(
                  GameObject(0,y),
                  {
                    zIndex: 101,
                    text,
                    length: -1,
                    height: 0,
                    step: 1,
                    draw: () => {
                      message = true;
                      _ctx.fillStyle = COLORS[0];
                      _ctx.beginPath();
                      _ctx.rect(0,state.y,240,state.height);
                      _ctx.fill();
                      if (state.step == 1) {
                          state.height += 5;
                          state.y -= 2.5;
                          if (state.height >= 50)
                              state.step = 2;
                      }
                      if (state.step == 2) {
                          state.length -= 1;
                          _ctx.fillStyle = COLORS[3];
                          _ctx.font = "bold 24px Arial"
                          _ctx.fillText(state.text,10,state.y + 32);
                          if (state.length <= 1 && state.length > 0)
                              state.step = 3;
                          if (state.length < 0 && mouse.click)
                              state.step = 3;
                      }
                      if (state.step == 3) {
                          state.height -= 5;
                          state.y += 2.5;
                          if (state.height <= 0) {
                              state.step = 4;
                              message = false;
                              remove(state);
                              state.draw = null;
                              if (callBack)
                                  callBack();
                              return;
                          }
                      }
                    },
                  }
                );

                /* How long should the message appear for */
                if (length)
                    state.length = length;

                return state;
            };

            /* Simple timer */
            const Timer = (time,callBack) => {
              let state = Object.assign(
                GameObject(0,0),
                {
                  time: Date.now() + time,
                  draw: () => {
                    if (Date.now() >= state.time) {
                      if (callBack)
                        callBack();

                      remove(state);
                    }
                  }
                }
              );
              return state;
            };


            function pushGroup(x,y,enemy) {
                let newGroup = add(Group(x, y,enemy));
                if (enemy == true) {
                    enemyGroups.push(newGroup);
                } else {
                    groups.push(newGroup);
                    newGroup.group = String.fromCharCode(65 + groups.length-1);
                }
                return newGroup;
            }

            function add(obj,last) {
                obj.ID = objId++;
                objects.push(obj);
                return obj;
            }

            function remove(obj) {
                if (obj.ID != null)
                    for (let i=0;i<objects.length;i++) {
                        if (obj.ID == objects[i].ID) {
                            objects.splice(i,1);
                            return obj;
                        }
                    }
                return null;
            }
            /*Game Start Code*/
            function gameStart() {
                switchState(MENU_STATE);
                bgDraw();
            }

            function switchState(newState) {
                objects = [];
                groups = [];
                enemyGroups = [];
                whichEnemy = 0;
                movingGroup = null;
                attackGroup = null;
                targetedSprite = null;
                message = false;
                buildings = [];
                bMActive = false;
                _canvas.style.cursor = "default";
                gameState = newState;
            }

            function beginLevel() {
                switchState(GAME_STATE);
                turn = "player";
                /* Switch background */
                bgDraw();
                /* Start turn after flash */
                startFX(FLASH,{complete: () => {
                    if (gameState == GAME_STATE)
                        turnSwitch(true);
                }, time: 20});
                if (level == 1) {
                    /* Create player */
                    shuffleGroup(createTroops(20,0,0,pushGroup(110,110)),12);
                    /* Create Enemies */
                    shuffleGroup(createTroops(10,0,0,pushGroup(20,110,true)),12);
                    shuffleGroup(createTroops(7,0,0,pushGroup(20,50,true)),12);
                    shuffleGroup(createTroops(7,0,0,pushGroup(150,150,true)),12);
                } else if (level == 2) {
                    shuffleGroup(createTroops(10,0,0,pushGroup(50,50)),12);
                    shuffleGroup(createTroops(10,0,0,pushGroup(200,200)),12);
                    shuffleGroup(createTroops(5,0,0,pushGroup(110,110,true)),12);
                    shuffleGroup(createTroops(15,0,0,pushGroup(300,300,true)),12);
                } else if (level == 3) {
                    //Players
                    shuffleGroup(createTroops(50,0,0,pushGroup(100,50)),12);
                    //Enemies
                    shuffleGroup(createTroops(70,0,0,pushGroup(-50,300,true)),12);
                } else {
                    /* PANIC! This is an error. Just reset game */
                    gameStart();
                }
            }

            function enemyTurn() {
                /* If there are no enemies, don't bother */
                if (enemyGroups.length < 1) {
                    turnSwitch(true);
                    return;
                }
            }

            function turnSwitch(player) {
                if (player == true) {
                    turn = "buildings";
                    add(Message("PLAYER TURN",120,90));
                    /* Reset all groups */
                    for (let i=0;i<groups.length;i++) {
                        if (groups[i])
                          groups[i].actions = 2;
                    }
                } else {
                    whichEnemy = 0;
                    turn = "enemy";
                    add(Message("ENEMY TURN",120,90,enemyTurn));
                    for (let i=0;i<enemyGroups.length;i++) {
                        if (enemyGroups[i])
                            enemyGroups[i].actions = 2;
                    }
                }
            }

            function createTroops(num,x,y,group) {
                for (let i=0;i<num;i++) {
                    if (group.enemy == true) {
                        group.members.push(Troop(x,y,6));
                    } else {
                        group.members.push(Troop(x,y,Math.floor(Math.random() * 6)));
                    }
                }
                return group;
            }

            /* Fun extra visual function (can be cut for more space) */
            function shuffleGroup(group,magnitude) {
                for (let i=0;i<group.members.length;i++) {
                    group.members[i].goto = [Math.random() * magnitude*2 - magnitude,Math.random() * magnitude*2 - magnitude]
                }
                return group;
            }

            /* Visual flare to indicate that sprite is active */
            function targetSprite(obj, time, callBack) {
              if (obj.x && obj.y)
                targetedSprite = obj;

              add(Timer(time,() => {
                targetedSprite = null;
                callBack();
              }));
            }

            function sortObjects() {
                /* Sort buildings */
                let error = false;
                if (buildings)
                  do {
                      error = false;
                      for (let i=0;i<buildings.length-1;i++) {
                          if (buildings[i].y < buildings[i+1].y) {
                              let temp = buildings[i];
                              buildings[i] = buildings[i+1];
                              buildings[i+1] = temp;
                              error = true;
                          }
                          buildings[i].zIndex = 1 - i/10;
                      }
                  } while (error == true);

                /* Sort every other sprite */
                do {
                    error = false;
                    for (let i=0;i<objects.length-1;i++) {
                        if (objects[i].zIndex > objects[i+1].zIndex) {
                            let temp = objects[i];
                            objects[i] = objects[i+1];
                            objects[i+1] = temp;
                            error = true;
                        }
                    }
                } while (error == true);
            }

            function draw() {
                requestAnimationFrame(draw);
                /* STATE MANAGER */
                if (gameState == GAME_STATE) {
                    if (turn == "enemy")
                        gameEnemyUpdate();
                    else if (turn == "player")
                        gameUpdate();
                    else if (turn == "buildings")
                        gameBuildingsUpdate();
                } else if (gameState == MENU_STATE) {
                    menuUpdate();
                }
                sortObjects();
                _ctx.clearRect(0,0,480,480);
                /*Sprites*/
                for (let i=0;i<objects.length;i++) {
                    objects[i].draw();
                }

                /*Game State specific stuff */
                if (gameState == GAME_STATE) {
                    /* Border around range */
                    if (movingGroup != null) {
                        _ctx.beginPath();
                        for (let i=0;i<20;i++) {
                            let startAngle = (Math.PI*2/20)*i + movingGroup.rangeAngle;
                            let endAngle = startAngle + Math.PI*2/40
                            _ctx.moveTo(movingGroup.range[0] + Math.cos(startAngle)*movingGroup.range[2],movingGroup.range[1] + Math.sin(startAngle)*movingGroup.range[2]);
                            _ctx.arc(movingGroup.range[0],movingGroup.range[1],movingGroup.range[2],startAngle,endAngle);
                        }
                        _ctx.stroke();
                        movingGroup.rangeAngle += Math.PI / 100;
                    }

                    /*Targeted sprite*/
                    if (targetedSprite != null) {
                      /* Draw target around sprite */
                      _ctx.drawImage(graphics,16*6,16,16,16,targetedSprite.x - 8,targetedSprite.y - 8,16,16);
                    }

                    /* HUD */
                    if (bMActive == false) {
                        _ctx.fillStyle = COLORS[1];
                        _ctx.strokeStyle = COLORS[0];
                        _ctx.beginPath();
                        _ctx.rect(-2,-2,244,16);
                        _ctx.fill();
                        _ctx.stroke();
                        _ctx.textAlign = "center";
                        let txt;
                        if (movingGroup != null) {
                            txt = "Moving Group";
                        } else if (attackGroup != null) {
                            txt = "Select Enemy Group to Attack"
                        } else if (turn == "player" || turn == "buildings") {
                            txt = "Player's Turn";
                        } else if (turn == "enemy") {
                            txt = "Enemy's Turn";
                        } else {
                            txt = "";
                        }
                        _ctx.font = "bold 8px Arial";
                        _ctx.fillStyle = COLORS[3];
                        _ctx.fillText(txt,120,10);
                        _ctx.textAlign = "left";
                    }
                } else if (gameState == MENU_STATE) {
                    /*Sine wave*/
                    let flag = {x: 25, y: 90,period: 1.5,size: 50,width:80,wave: 5};
                    flag.y = flag.y - flag.wave*Math.sin((((sineOffset)/flag.width-1)*(Math.PI*2))/flag.period);
                    _ctx.beginPath();
                    _ctx.fillStyle = COLORS[3];
                    for (let s=0;s<2;s++) {
                        if (s==0)
                            _ctx.moveTo(flag.x,(flag.y + s*flag.size)+flag.wave*Math.sin((((sineOffset)/flag.width-1)*(Math.PI*2))/flag.period));
                        else if (s==1)
                            _ctx.lineTo(flag.x+flag.width-1,flag.y+flag.size + flag.wave*Math.sin((((sineOffset+flag.width-1)/flag.width-1)*(Math.PI*2))/flag.period));
                        for (let i=0;i<flag.width;i++) {
                            if (s==0)
                                _ctx.lineTo(flag.x+i,(flag.y + s*flag.size)+flag.wave*Math.sin((((i+sineOffset)/flag.width-1)*(Math.PI*2))/flag.period));
                            if (s==1)
                                _ctx.lineTo(flag.x+flag.width-1-i,(flag.y + s*flag.size)+flag.wave*Math.sin((((flag.width-i+sineOffset)/flag.width-1)*(Math.PI*2))/flag.period));
                        }
                    }
                    _ctx.closePath();
                    _ctx.fill();
                    sineOffset--;
                }

                /*Release mouse click event*/
                mouse.click = false;

                /* If fx are active then draw them */
                if (fx != {}) {
                    fxDraw();
                }

                /* Debug FPS
                if (debug) {
                    frames++;
                    if (Date.now() - deltaTime >= 1000) {
                        deltaTime = Date.now();
                        fps = frames;
                        frames = 0;
                    }
                    _ctx.fillStyle = "#FF0000";
                    _ctx.font = "bold 8px Arial";
                    _ctx.textAlign = "left";
                    _ctx.fillText("FPS: "+fps,0,10);
                }*/
            }

            /* Run this function if all the player groups die */
            function gameOver() {
                turn = "gameOver";
                add(Message("GAME OVER!",120,-1, gameStart));
            }

            function win() {
                turn = "win";
                level++;
                add(Message("STAGE CLEAR",120,-1, () => {
                    startFX(FADE,{complete: beginLevel, time: 20});
                }));
            }

            function gameUpdate() {
                /* Move group if appropiate */
                if (movingGroup != null) {
                    distance = Math.sqrt(Math.pow((movingGroup.range[0] - mouse.x),2) + Math.pow((movingGroup.range[1] - mouse.y),2));
                    if (distance < movingGroup.range[2]) {
                        movingGroup.goto = [mouse.x - 8,mouse.y - 8];
                    } else {
                        let angle = Math.atan(((mouse.y - 8) - movingGroup.range[1])/((mouse.x - 8) - movingGroup.range[0]));

                        let direction = [1,1];
                        if ((mouse.x - 8) - movingGroup.range[0] < 0) {
                            direction[0] = -1;
                            direction[1] = -1;
                        }


                        movingGroup.goto = [movingGroup.range[0]-8 + Math.cos(angle)*movingGroup.range[2]*direction[0],movingGroup.range[1]-8 + Math.sin(angle)*movingGroup.range[2]*direction[1]];
                    }
                    if (mouse.click) {
                        movingGroup.actions -= 1;
                        mouse.click = false;
                        movingGroup = null;
                    }
                }
                /* Check if player groups are still alive */
                let alive = false;
                for (let i=0;i<groups.length;i++) {
                    if (groups[i] != null)
                        alive = true
                }
                if (alive == false) {
                    gameOver();
                    return;
                }

                /* Check if enemy groups are still alive */
                alive = false;
                for (let i=0;i<enemyGroups.length;i++) {
                    if (enemyGroups[i] != null)
                        alive = true
                }
                if (alive == false) {
                    win();
                    return;
                }

                /* End turn when all actions are used up */
                if (groups && turn == "player")
                    if (groups.length > 0) {
                        let totalActions = 0;
                        for (let i=0;i<groups.length;i++)
                            if (groups[i])
                                totalActions += groups[i].actions;
                        if (totalActions == 0)
                            turnSwitch(false);
                    }
            }

            function gameBuildingsUpdate() {
                /* Disable mouse click during buildings' actions */
                mouse.click = false;
                if (message != false)
                  return;
                for (let i=0; i < buildings.length; i++) {
                  if (buildings[i].actionStatus == "start")
                    buildings[i].action();
                  if (buildings[i].actionStatus != "complete")
                    return;
                }

                /* Once all building actions are complete switch control to player and reset buildings*/
                for (let i=0; i < buildings.length; i++)
                  buildings[i].actionStatus = "start";
                turn = "player";
            }

            function gameEnemyUpdate() {
                let e = enemyGroups[whichEnemy];
                if (message == false && enemyGroups[whichEnemy] && enemyGroups[whichEnemy].goto == null) {
                    /* This is the enemy AI
                        Priorities:
                        1) Move towards enemy
                        2) Attack when in range
                    */

                    /* Priority 1:
                    Move enemy towards player
                    Determine closest player and move maximum range towards it. Move just close enough to attack
                    Goal: Choose weakest and closest group to move towards and attack
                    */
                    /* Determine what to advance on */
                    let distances = [];
                    let target = 0;
                    for (let i=0; i < groups.length; i++) {
                        distances[i] = Math.sqrt(Math.pow(groups[i].x - e.x,2)+Math.pow(groups[i].y - e.y,2));
                        if (distances[i-1] && distances[i] < distances[i-1])
                            target = i;
                    }
                    /* Make sure target is worth going for and that the enemy can even still move*/
                    if (Math.floor(distances[target]) > 42 && e.actions > 0) {
                        if (distances[target] > e.range[2] && distances[target] - e.range[2] > 42) {
                            let ratio = e.range[2] / distances[target];
                            e.goto = [];
                            e.goto[0] = (groups[target].x - e.x)*ratio + e.x;
                            e.goto[1] = (groups[target].y - e.y)*ratio + e.y;
                            e.actions -= 1;
                            return;
                        } else {
                            let direction = [groups[target].x - e.x,groups[target].y - e.y];
                            direction = [-Math.abs(direction[0])/direction[0],-Math.abs(direction[1])/direction[1]];
                            if (isNaN(direction[0]))
                                direction[0] = 0;
                            if (isNaN(direction[1]))
                                direction[1] = 0;

                            let angle = Math.atan(-(e.y - groups[target].y) / (e.x - groups[target].x));
                            e.goto = [groups[target].x + Math.abs(42*Math.cos(angle))*direction[0],groups[target].y + Math.abs(42*Math.sin(angle))*direction[1]];
                            e.actions -= 1;
                            return;
                        }
                    }

                    /* Priority 2
                    Attack the closest player group
                    */
                    if (e.actions > 0 && groups[target]) {
                        let counter = groups[target].members.length;
                        groups[target].members.splice(0,e.members.length);

                        e.members.splice(0,counter / 2);

                        shuffleGroup(e,12);
                        shuffleGroup(groups[target],12);

                        e.actions -= 1;
                        return;
                    }


                    /* If no other actions can be done rest */
                    e.actions = 0;
                }
                if (enemyGroups[whichEnemy] && e.actions == 0 || enemyGroups[whichEnemy] == null && message == false)
                    whichEnemy++;

                /* Check to see if there are any players still standing */
                if (groups.length == 0) {
                    gameOver();
                    return;
                }

                /* Check if enemy groups are still alive */
                if (enemyGroups.length == 0) {
                    win();
                    return;
                }

                if (message == false && whichEnemy == enemyGroups.length) {
                    turnSwitch(true);
                }
            }

            /* Update logic for the main menu */
            function menuUpdate() {
                /* Click the start button */
                if (mouse.x > 165 -52 && mouse.x < 165+52 && mouse.y > 168 && mouse.y < 202) {
                    _canvas.style.cursor = "pointer";
                    if (mouse.click && !fx.type) {
                        level = 1;
                        startFX(CIRCLE_TRANSITION,{complete: beginLevel});
                        _canvas.style.cursor = "default";
                    }
                } else {
                    _canvas.style.cursor = "default";
                }
            }

            /*
                Types and Options:
                1) Circle Transition:
                    - Speed
                    - Density
                    - Complete
                2) Fade
                    - Color
                    - Time
                    - Complete
                3) Flash
                    - Color
                    - Time
                    - Complete
            */
            function startFX(type,options) {
                fx = {type: type, options: options};
                if (type == CIRCLE_TRANSITION) {
                    if (options.density == null)
                        options.density = 5;
                    if (options.speed == null)
                        options.speed = 5;
                    fx.circles = [];
                    /* Build the 2d array */
                    for (let i=0;i<options.density;i++)
                        fx.circles[i] = [];
                    /* p = y cord, i = x cord */
                    for (let p=0;p<options.density;p++)
                        for (let i=0;i<options.density;i++)
                            fx.circles[i][p] = 0;

                    fx.radius = 0;
                }
                if (type == FADE) {
                    if (options.color == null)
                        options.color = COLORS[0];
                    if (options.time == null)
                        options.time = 100;
                    fx.opacity = 0;
                }
                if (type == FLASH) {
                    if (options.color == null)
                        options.color = COLORS[0];
                    if (options.time == null)
                        options.time = 100;
                    fx.opacity = 1;
                }
            }

            function fxDraw() {
               if (fx.type === CIRCLE_TRANSITION) {
                   /* p = y cord, i = x cord */
                   let separation = 240 / fx.options.density;
                   let finished = true;
                    for (let p=0;p<fx.options.density;p++)
                        for (let i=0;i<fx.options.density;i++) {
                            /* Don't grow circles forever */
                            if (fx.circles[i][p] < separation) {
                                finished = false;
                            }
                            if (Math.sqrt(Math.pow(p*separation-120+separation/2,2)+Math.pow(i*separation-120+separation/2,2)) <= fx.radius) {
                                fx.circles[i][p]++;
                            }
                            /* If the circle's radius is more than 0 draw it*/
                            if (fx.circles[i][p] > 0) {
                                _ctx.fillStyle = COLORS[0];
                                _ctx.beginPath()
                                _ctx.arc(i*separation+separation/2,p*separation+separation/2,fx.circles[i][p],0,Math.PI*2);
                                _ctx.fill();
                            }
                        }
                    fx.radius+= fx.options.speed;
                   if (finished == true) {
                       let complete = fx.options.complete;
                       fx = {}
                       if (complete)
                           complete();
                   }
                }
                /* Fade transition */
                else if (fx.type == FADE) {
                    _ctx.beginPath();
                    _ctx.globalAlpha = fx.opacity;
                    _ctx.fillStyle = fx.options.color;
                    _ctx.rect(0,0,WIDTH/2,HEIGHT/2);
                    _ctx.fill();
                    _ctx.globalAlpha = 1;
                    fx.opacity += 1/fx.options.time;
                    /* When complete */
                    if (fx.opacity >= 1) {
                        let complete = fx.options.complete;
                        fx = {}
                        if (complete)
                            complete();
                    }
                }
                /* Flash effect */
                else if (fx.type == FLASH) {
                    _ctx.beginPath();
                    _ctx.globalAlpha = fx.opacity;
                    _ctx.fillStyle = fx.options.color;
                    _ctx.rect(0,0,WIDTH/2,HEIGHT/2);
                    _ctx.fill();
                    _ctx.globalAlpha = 1;
                    fx.opacity -= 1/fx.options.time;
                    /* When complete */
                    if (fx.opacity <= 0) {
                        let complete = fx.options.complete;
                        fx = {}
                        if (complete)
                            complete();
                    }
                }
            }

            /* Background layer doesn't have to be drawn every frame */
            function bgDraw() {
                _bgCtx.clearRect(0,0,480,480);
                if (gameState == GAME_STATE) {
                    /*Background*/
                    for (var r=0;r<240/16;r++) {
                        for (var c=0;c<240/16;c++) {
                            _bgCtx.drawImage(graphics,0,16,16,16,c*16,r*16,16,16);
                        }
                    }
                } else if (gameState == MENU_STATE) {
                    /* Title Menu */
                    /* Background */
                    _bgCtx.fillStyle = COLORS[1];
                    _bgCtx.beginPath();
                    _bgCtx.rect(0,0,240,120);
                    _bgCtx.fill();
                    _bgCtx.fillStyle = COLORS[2];
                    _bgCtx.beginPath();
                    _bgCtx.rect(0,120,240,120);
                    _bgCtx.fill();
                    /* Sun (even though it looks like a moon)*/
                    _bgCtx.fillStyle = COLORS[3];
                    _bgCtx.beginPath();
                    _bgCtx.arc(200,43,25,0,Math.PI*2);
                    _bgCtx.fill();
                    /*Castle Begin*/
                    _bgCtx.fillStyle = COLORS[0];
                    _bgCtx.beginPath();
                    _bgCtx.rect(100,70,130,70);
                    _bgCtx.fill();
                    _bgCtx.beginPath();
                    _bgCtx.rect(100,50,20,20);
                    _bgCtx.fill();
                    _bgCtx.beginPath();
                    _bgCtx.rect(100,50-20/3,20/3,20/3);
                    _bgCtx.fill();
                    _bgCtx.beginPath();
                    _bgCtx.rect(100+40/3,50-20/3,20/3,20/3);
                    _bgCtx.fill();
                    _bgCtx.beginPath();
                    _bgCtx.rect(210,50-20/3,20/3,20/3);
                    _bgCtx.fill();
                    _bgCtx.beginPath();
                    _bgCtx.rect(210+40/3,50-20/3,20/3,20/3);
                    _bgCtx.fill();

                    _bgCtx.beginPath();
                    _bgCtx.rect(165-15,20,30,50);
                    _bgCtx.fill();

                    _bgCtx.beginPath();
                    _bgCtx.rect(165-15,20-30/3,30/3,30/3);
                    _bgCtx.fill();

                    _bgCtx.beginPath();
                    _bgCtx.rect(165-15 + 60/3,20-30/3,30/3,30/3);
                    _bgCtx.fill();

                    /*Right Arm*/
                    _bgCtx.beginPath();
                    _bgCtx.moveTo(180,50);
                    _bgCtx.lineTo(190,40);
                    _bgCtx.lineTo(190,20);
                    _bgCtx.lineTo(200,20);
                    _bgCtx.lineTo(200,50);
                    _bgCtx.lineTo(180,60);
                    _bgCtx.closePath();
                    _bgCtx.fill();
                    /* Left Arm */
                    _bgCtx.beginPath();
                    _bgCtx.moveTo(150,50);
                    _bgCtx.lineTo(140,40);
                    _bgCtx.lineTo(140,20);
                    _bgCtx.lineTo(130,20);
                    _bgCtx.lineTo(130,50);
                    _bgCtx.lineTo(150,60);
                    _bgCtx.closePath();
                    _bgCtx.fill();

                    _bgCtx.beginPath();
                    _bgCtx.rect(210,50,20,20);
                    _bgCtx.fill();

                    /*Flag pole*/
                    _bgCtx.beginPath();
                    _bgCtx.rect(20,85,5,130);
                    _bgCtx.fill();

                    /* Start Button */
                    let bP = {x: 165 - 50, y: 170}
                    _bgCtx.strokeStyle = COLORS[3];
                    _bgCtx.lineWidth = 2;
                    _bgCtx.fillStyle = COLORS[2];
                    _bgCtx.beginPath();
                    _bgCtx.rect(bP.x,bP.y,100,30);
                    _bgCtx.fill();
                    _bgCtx.stroke();
                    _bgCtx.fillStyle = COLORS[1];
                    _bgCtx.beginPath();
                    _bgCtx.rect(bP.x - 1,bP.y + 31,102,5);
                    _bgCtx.fill();
                    _bgCtx.fillStyle = COLORS[1];
                    _bgCtx.textAlign = "center";
                    _bgCtx.font = "bold 18px Arial";
                    _bgCtx.fillText("Start",bP.x + 50,bP.y + 22);

                    /*Title text*/
                    _bgCtx.shadowColor = COLORS[2];
                    _bgCtx.shadowOffsetY = 2;
                    _bgCtx.font = "bold 32px Arial";
                    _bgCtx.textAlign = "center";
                    _bgCtx.fillStyle = COLORS[3];
                    _bgCtx.fillText("Split",47,33);
                    _bgCtx.fillText("Army",47,63);
                    _bgCtx.shadowOffsetY = 0;
                }
            }

            /* Extra Stuff */
            document.getElementById("f").onclick = () => {
                if (fullscreen == false) {
                    if (_gameDiv.webkitRequestFullscreen)
                        _gameDiv.webkitRequestFullscreen();
                    if (_gameDiv.requestFullscreen)
                        _gameDiv.requestFullscreen();
                    if (_gameDiv.mozRequestFullScreen)
                        _gameDiv.mozRequestFullScreen();
                    if (_gameDiv.msRequestFullscreen)
                        _gameDiv.msRequestFullscreen();
                } else {
                    if (document.exitFullscreen)
	                   document.exitFullscreen();
                    if (document.webkitExitFullscreen)
                        document.webkitExitFullscreen();
                    if (document.mozCancelFullScreen)
                        document.mozCancelFullScreen();
                    if (document.msExitFullscreen)
                        document.msExitFullscreen();
                }
            }
            /* Resize Canvas for fullscreen-ness */
            function FShandler() {
                let canvases = _gameDiv.childNodes;
                if (fullscreen == false) {
                    fullscreen = true;
                    if (window.screen.width > window.screen.height) {
                        _gameDiv.style.height = screen.height;
                        _gameDiv.style.width = screen.height;
                        _gameDiv.style.margin = "auto";
                        for (var i=0; i<canvases.length;i++){
                            canvases[i].style.width = screen.height;
                            canvases[i].style.height = screen.height;
                            if (_gameDiv.offsetWidth > screen.height)
                                canvases[i].style.left = screen.width/2 - screen.height/2;
                        }
                    } else {
                        _gameDiv.style.width = screen.width;
                        _gameDiv.style.height = screen.width;
                        _gameDiv.style.margin = "auto";
                        for (var i=0; i<canvases.length;i++){
                            canvases[i].style.width = screen.width;
                            canvases[i].style.height = screen.width;
                            if (_gameDiv.offsetHeight > screen.width)
                                canvases[i].style.top = screen.height/2 - screen.width/2;
                        }
                    }
                } else {
                    fullscreen = false;
                    _gameDiv.style.width = _canvas.width;
                    _gameDiv.style.height = _canvas.height;
                    _gameDiv.style.margin = 0;
                    for (let i=0; i<canvases.length;i++){
                            canvases[i].style.width = _canvas.width;
                            canvases[i].style.height = _canvas.width;
                            canvases[i].style.left = 0;
                            canvases[i].style.top = 0;
                    }
                }
            }
            document.addEventListener("fullscreenchange", FShandler);
            document.addEventListener("webkitfullscreenchange", FShandler);
            document.addEventListener("mozfullscreenchange", FShandler);
            document.addEventListener("MSFullscreenChange", FShandler);

            document.onmousemove =  (e) => {
                let rect = _canvas.getBoundingClientRect();
                mouse.x = Math.round((e.clientX-rect.left)/(rect.right-rect.left)*_canvas.width/2);
                mouse.y = Math.round((e.clientY-rect.top)/(rect.bottom-rect.top)*_canvas.height/2);
            }
            document.onmousedown = (e) => {mouse.down = true; mouse.click = true;}
            document.onmouseup = (e) => {mouse.down = false;}
            document.addEventListener("touchstart", (e) => {mouse.down = false; mouse.click = true;}, false);
            document.addEventListener("touchend", (e) => {mouse.down = true;}, false);

            /*Start game*/
            draw();
            gameStart();
        }
    </script>
</html>
<!--
opengameart.org
Videlais for the tile sheet
darkagent for players and enemies

lospec.com
Kirokaze for Pallet
!-->
<img id="g" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAAAgCAYAAADKbvy8AAAGCUlEQVRoge1aMWsjRxT+JiSdiwORa3L+A8YGgwyHKjXGwXHikwpDQDbEQZDCW+S6+Bdcec2mOBDYIAsChliJ4xgbNapcCQIR+QOKr3AiSKEmXDEppLeenX0zO7PaPafwB2ZXMzszb+eb9943swYe8YhHPByElDJeIMQDmXKP8nJNAkgYUmpU5fXhy8wG6u9KEEJASgkhBMrLNTkYdtkxbHUPhQ9NFatLW/K3Py4EXV06Ky/X6JabKQEAg2HX1bZEH+NO37WtF3TyOKJsdSbMFiIAoCjiWQJXl7bk0711bGBdAsBqG84kEs5uwui+XgkyG7h/OcHR5kJ0dcHGq9cJ8m2eS1FHmWShTj6Vac+wUBdxqVFFK9hBMzxFuYMoqqQtYmZs47gJAleXttg44+GJEgCa4SlX7roIBCxenIbt3YtE2fWh48hTSAAoNaoAIs/3sV8CQCvYwY9/76IVnKDu2Ed5uSbVxU+oV8B6vjGE3rV7jrbyyCvckde5eh8AbD85TpQFeOY1bqlRjd5Bvfdpb+rPBBN5wDSicSQaCXy6t467di+6OiK2clV4rmJebTiuYC5km4RRXqA8CsX2ZniKVnCiR6NUOzj7TcR+oBdQmCTS6OqbAwE+lKWhvFyTtABKjWr0R7+5/KBBANPcqV7hQd5g2BWqt4w7fV8RIsadPsadPuqVAHTvagPnvSYkCASSZGUhDwB+PtnK0iwXZAm9BMZbOVETQVexM5EigNjki8GwC1KytvFbwU5s8baCHeOziRA6U1FSZb3c+UiSAS7II//pOcO2Cm3ts+QvIFKKEYmKunSFBGJzkRo6B8OuqFcgz27CBGn1SsBGAS4HRqtje/dC9aJCcwhwHz65CVcFRbnDKzJgOvEbr17HyCs1qrg+fOlsh77f893A03u0gh3UKwHObsJoK5HWD5HIlXPPG0UMkCkEmuS/Ws+ivFyT03x1gaPOgt6XAKDXG0Fk61cfqBP2vk5fKLTunf+DX394EZV/9uVPwBfTOmcVmkMYVAey5o+1lbo8uwmx/fwbNK/+Jc9R28ipjA6wfzlJ9cL/C5rhKUqNKrcnTkDdQkzf814AHm0+wX1d/L1ZETODUP4eCvOML7RrYWBOcgBMxchdu5fIZ64Lz0WAcR441ymIL2YvL7afv4vGvGv3dOUbywsZZP17xWDYFavtd7I5+90MT7l3SrShd1S2PqDftDfU31tw54Y+uPru21iHayt1nN2ELn0KdcPq2mZx4RNj5WhyK9VwRQJGBVeml+sCSH1mFsoiO9ZW6pwppndJEOhxuJ9AOFqXVhEzD5rhqTGPziYhcWxkO/Q2nUToUNVqFphsdtQEaYtQFWVzIRxNPzQURqC+itUrkWuqn2cPR21sCtSFJK59yqKIyCPBlfJsLimgMALVyZ/3msWb9NBn6scWLrk+DIiR5whvEsnrgsVe1C53AimX2SbEdG+qG3f6gOU4SYU+0eNOH88+X8Gfv/xubceRyPZtsUMlz0Rklm+jRBwQJw9QRAyduminL6nQRYwqJPL6pKSdBxqFTBFjqzYASNixtlKXgJfnxUhMU9Oc16nl0T4wC3km6CFL/6Jgu+d+06m+DaPJbUxAcP34jquWEV5UvmbHPzi+Sp8YT5jIU8tiITSvrwe6+PC953675EGa3I8bm9bnsubWvzqXxrq3b85xAOD7rz4FkCSUyl1hI48QLPZEISKGm6C0HJgmJlzyIBFnWxicna5laQtDJfHtm/N4pQeBLuQRCiFQl/KENO8zSf80cWGywdaHzcO5xeSaU4nErPAhD3AkMIvA8ZHmLoo0T5i8LK+xVO/zETcEV/IA+2F2BFfySEj4KEDXzbr6YXQ0uTU+k6f65HI50/88G3JWWXp1kOdZKMn4vCU8kJDxia1EkWPrdqg2zM5CjXOoe+DB8ZXqobH/cghH69LH+4CCT2IIvqHS8xTEOHaWXGayMaWt8UO2rkZV8vRnfckDCiDQ9JK+YsDYr8eJTBH50wKWxIQavX82Ahc6XcksJIQCxZyEcJ9z1LFzHTAdagjV4fw5af9yYrTbhcT/AMeITxGoTTqZAAAAAElFTkSuQmCC" alt="" />
