<html>
    <head>
        <style>
            img {
                display: none;
            }
            canvas {
                -ms-interpolation-mode: nearest-neighbor;
                image-rendering: -webkit-optimize-contrast;
                image-rendering: -webkit-crisp-edges;
                image-rendering: -moz-crisp-edges;
                image-rendering: -o-crisp-edges;
                image-rendering: pixelated;
                /*width: 100%;
                height: auto;*/
            }
            html, body {
                margin: 0;
            }
            #f {
                width: 70px;
                height: 70px;
                position: absolute;
                background-color: black;
                top: 480px;
            }
            #game {
                position: absolute;
                width: 480px;
                height: 480px;
                display: block;
                overflow: hidden;
            }
            #game *{
                position: absolute;
                top:0;
                left: 0;
                display: block;
                margin: auto;
            }
        </style>
    </head>
    <body>
        <div id="f"></div>
        <div id="game"></div>
    </body>
    <!-- Import external code !-->
    <script src="astar.js"></script>
    <script src="levelData.js"></script>
    <!--Javascript code starts here !-->
    <script>
    	/* Engine Constants */
    	/* Pallet */
        const COLORS = ["#332c50","#46878f","#94e344","#e2f3e4"];
        /* FX */
        const CIRCLE_TRANSITION = 0x0001;
        const FADE = 0x0010;
        const FLASH = 0x0100;
        /* States */
        const GAME_STATE = 1;
        const MENU_STATE = 2;
        /* Game Size */
        const WIDTH = 480;
        const HEIGHT = 480;
        const TILEWIDTH = WIDTH/10;
        const TILEHEIGHT = 226/5;

        let _lastTime = Date.now();
        let deltaTime = 1;
        let fullscreen = false;
        window.onload = () => {
            /* Game div */
            let _gameDiv = document.getElementById("game");
            /* Background layer */
            let _bgCanvas = document.createElement("CANVAS");
            _bgCanvas.width = WIDTH;
            _bgCanvas.height = HEIGHT;
            let _bgCtx = _bgCanvas.getContext("2d");
            /*Pixel Perfect*/
            _bgCtx.imageSmoothingEnabled = false;
            /*Scale up game*/
            _bgCtx.scale(2,2);
            /* Foreground layer */
            let _canvas = _gameDiv.appendChild(document.createElement("CANVAS"));
            _canvas.width = WIDTH;
            _canvas.height = HEIGHT;
            let _ctx = _canvas.getContext("2d");
            /*Pixel Perfect*/
            _ctx.imageSmoothingEnabled = false;
            /*Scale up game*/
            _ctx.scale(2,2);

            /* Assign graphics their own variable */
            let graphics = document.getElementById("g");
            let _tiles = document.getElementById("t");

            let objects = [];
            let objId = 0;
            let mouse = {x:0,y:0,down:false,click:false};
            let fx = {};
            let sineOffset = 0;

            /* Game variables */
            let groups;
            let enemyGroups;
            let whichEnemy;
            let movingGroup;
            let message;
            let buildings;
            let menuActive;
            let turn;
            let attackGroup;
            let gameState;
            let level;
            let currentBuilding = 0;
            let enablePlayer;
            let _tileSelector;
            let _tileLayout = [];

            /* Objects */
            const GameObject = (x,y) => {
                let state = {
                  x,
                  y,
                  zIndex: 0,
                  ID: 0,
                  alpha: 1,
                  draw: () => {},
                  update: () => {},
                  fade: (time,alpha,callBack) => {
                    let speed = (1000/time)*(alpha - state.alpha)/60;
                    add(Timer(time,()=> {
                      if (callBack) {
                        callBack();
                      }
                    },()=> {
                      state.alpha += speed*deltaTime;
                      if (state.alpha < 0)
                        state.alpha = 0;
                      if (state.alpha > 1)
                        state.alpha = 1;
                    }))
                  },
                }
                return state;
            };

            const Troop = (x,y,frame) => {
                /* Have troop extend GameObject */
                let state = Object.assign(
                  GameObject(x,y),
                  {
                    zIndex: 1,
                    frame,
                    group: 1,
                    goto: null,
                    draw: () => {
                      _ctx.drawImage(graphics,state.frame*16,0,16,16,state.x,state.y,16,16);
                    },
                    update: () => {
                      if (state.goto != null) {
                          state.x += (Math.floor(state.goto[0] - state.x)/3)*deltaTime;
                          state.y += (Math.floor(state.goto[1] - state.y)/3)*deltaTime;
                          if (state.x == state.goto[0] && state.y == state.goto[1])
                              state.goto = null;
                      }
                    },
                  },
                );

                return state;
            };
            /* Building ideas:
            Attack tower
            Make more guys building
            Wall to stall for time
            */
            const Building = (x,y,type, display) => {
                /* Combine objects */
                let state = Object.assign(
                  GameObject(x,y),
                  {
                    mpBuild: 10,
                    zIndex: 1,
                    type,
                    tile: [],
                    draw: () => {
                      // Put into display mode
                      if (display == true) {
                        state.x = (state.x-8) / TILEWIDTH;
                        state.y = (state.y-21.25) / TILEHEIGHT;
                      }
                      if (state.type = "t") {
                          _ctx.drawImage(graphics,16,16,32,16,state.x*TILEWIDTH+8,state.y*TILEHEIGHT + 21.25,32,16);
                          _ctx.drawImage(graphics,48,16,32,16,state.x*TILEWIDTH+8,state.y*TILEHEIGHT + 21.25+16,32,16);
                          state.mpBuild = 10;
                      }
                      // Revert back to normal
                      if (display == true) {
                        state.x = state.x * TILEWIDTH + 8;
                        state.y = state.y * TILEHEIGHT + 21.25;
                      }
                    },
                    action: () => {
                      targetSprite(state,1000,() => {
                        if (state.type == "t") {
                          let range = 2;
                          for (let i=0; i < enemyGroups.length; i++) {
                              if (Math.sqrt(Math.pow(enemyGroups[i].x - state.x,2)+Math.pow(enemyGroups[i].y - state.y,2)) <= range) {
                                  enemyGroups[i].members.splice(0,Math.ceil(enemyGroups[i].members.length/10));
                                  //Kill enemy if out of health
                                  if (enemyGroups[i].members.length < 1){
                                    enemyGroups[i].fade(200,0,() => {
                                      enemyGroups[i].kill();
                                    });
                                  }
                              }
                          }
                        }
                        //Add a short buffer between building actions
                        add(Timer(200,() => {
                          buildingsActions();
                        }))
                      });
                    },
                    kill: () => {
                      for (let i=0;i<buildings.length;i++)
                        if (buildings[i].ID == state.ID)
                          buildings.splice(i,1);
                      remove(state);
                    },
                  }
                );
                return state;
            };

            const SplitSelector = (group, callBack) => {
              menuActive = true;
              let state = Object.assign(
                GameObject(0,0),
                {
                  ammountToSplit: group.members.length,
                  zIndex: 100,
                  _width: WIDTH,
                  _height: 0,
                  active: false,
                  draw: () => {
                    state.update();
                    _ctx.fillStyle = COLORS[2];
                    _ctx.rect(0, HEIGHT / 4 - state._height / 2, state._width, state._height);
                    _ctx.fill();
                  },
                  update: () => {
                    if (groups.length > 1) {
                      state.zIndex = 0;
                      remove(state);
                      callBack(group);
                    }
                  }
                }
              );
              add(Timer(250,() => {
                state._height = 200;
              }, () => {
                state._height += (200/15)*deltaTime;
              }))
              return state;
            }

            const BuildingMenu = (group) => {
              /* Menu's variables */
                let items = ["t","t","t","t","t","t"];
                let descriptions = [
                  "Attack Tower\n[10 MP]\nProvide assualt\nwithout risk at\nthe cost of MP."
                ];

                let state = Object.assign(
                  GameObject(0,0),
                  {
                    zIndex: 100,
                    dummyBuildings: [],
                    hover: null,
                    draw: () => {
                      state.update();
                      _ctx.textAlign = "center";
                      _ctx.strokeStyle = COLORS[0];
                      _ctx.lineWidth = 10;
                      _ctx.fillStyle = COLORS[3];
                      _ctx.beginPath();
                      _ctx.rect(0,0,240,240);
                      _ctx.fill();
                      _ctx.stroke();
                      _ctx.lineWidth = 2;
                      _ctx.fillStyle = COLORS[1];
                      _ctx.font = "bold 18px Arial"
                      _ctx.fillText("Building Menu",120,24);
                      _ctx.font = "bold 6px Arial"
                      for (let i=0;i<items.length;i++) {
                          state.dummyBuildings[i].draw();
                          if (descriptions[i]) {
                              _ctx.fillStyle = COLORS[1];
                              let text = descriptions[i].split("\n");
                              for (let t=0;t<text.length;t++) {
                                 if (t==0)
                                     _ctx.font = "bold 7px Arial";
                                  else
                                     _ctx.font = "bold 6px Arial";
                                  _ctx.fillText(text[t],state.dummyBuildings[i].x+16,state.dummyBuildings[i].y + 40 + 10*t);
                              }
                          }
                      }
                      /* Back Button */
                      _ctx.drawImage(graphics,80,16,16,16,14,10,16,16);
                      /* Flavor text */
                      _ctx.fillText("Group's MP: " + group.members.length,120,230);
                      _ctx.textAlign = "left";
                      if (state.hover != null) {
                          _ctx.beginPath();
                          _ctx.rect(state.hover.x-11,state.hover.y-5,56,90);
                          _ctx.stroke();
                      }
                    },
                    update: () => {
                      menuActive = true;
                      /* Check mouse position around each time and draw
                      a rectangle around it if selected */
                      state.hover = null;
                      if (state.dummyBuildings)
                      for (var i=0;i<state.dummyBuildings.length;i++) {
                          if (mouse.x > state.dummyBuildings[i].x-10 && mouse.x < state.dummyBuildings[i].x + 42 && mouse.y > state.dummyBuildings[i].y-5 && mouse.y < state.dummyBuildings[i].y + 85) {
                              state.hover = {x:state.dummyBuildings[i].x,y:state.dummyBuildings[i].y};
                              /* If clicked place build */
                              if (mouse.click && group.members.length >= state.dummyBuildings[i].mpBuild) {
                                  mouse.click = false;
                                  group.actions -= 1;
                                  /* Not to be confused with state.dummyBuildings (this is the global array) */
                                  let buildingType = state.dummyBuildings[i].type;
                                  _tileSelector.start(group.x,group.y,1,(pos) => {
                                    let localBuilding = add(Building(pos[0],pos[1],buildingType));
                                    localBuilding.tile = pos;
                                    buildings.push(localBuilding);
                                    //Check player status
                                    playerAction();
                                  });
                                  state.close();
                              }
                          }
                      }
                      /* Close menu if click on back button */
                      if (mouse.x > 14 && mouse.x < 30 && mouse.y > 10 && mouse.y < 26 && mouse.click) {
                          state.close();
                          playerAction();
                      }
                    },
                    close: () => {
                      for (let i=0;i<state.dummyBuildings.length;i++) {
                          remove(state.dummyBuildings[i]);
                      }
                      remove(state);
                      menuActive = false;
                    },
                  }
                );

                /* Add building sprites to dummyBuildings array */
                for (let i=0;i<items.length;i++) {
                  state.dummyBuildings.push(add(Building(20+55*(i%4),90*(Math.floor(i/4)+1) - 50,items[i],true)));
                }

                return state;
            };

            /* The group's x and y are measured in tiles, not cordinates */
            const Group = (x,y,enemy) => {
                let state = Object.assign(
                  GameObject(x,y),
                  {
                    zIndex: 3,
                    range: 16,
                    enemy: false,
                    members: [],
                    group: "A",
                    goto: null,
                    list: null,
                    actions: 3,
                    draw: () => {
                      state.update();
                      _ctx.globalAlpha = state.alpha;
                      for (let i=0;i<state.members.length;i++){
                          state.members[i].update();
                          state.members[i].x += state.x*TILEWIDTH+18;
                          state.members[i].y += state.y*TILEHEIGHT+26.5;
                          state.members[i].draw();
                          state.members[i].x -= state.x*TILEWIDTH+18;
                          state.members[i].y -= state.y*TILEHEIGHT+26.5;
                      }
                      _ctx.lineWidth = 2;
                      if (enemy == true) {
                          _ctx.beginPath();
                          _ctx.strokeStyle = COLORS[0];
                          _ctx.rect(state.x*TILEWIDTH+4,state.y*TILEHEIGHT +16.5,40,40);
                          _ctx.stroke();
                          /*Group info*/
                          _ctx.beginPath();
                          _ctx.fillStyle = COLORS[0];
                          _ctx.rect(state.x*TILEWIDTH + 32,state.y*TILEHEIGHT + 46.5,12,10);
                          _ctx.fill();
                          /*Info text*/
                          _ctx.fillStyle = COLORS[3];
                          _ctx.font = "bold 8px Arial"
                          _ctx.fillText(state.members.length,state.x*TILEWIDTH + 33.5,state.y*TILEHEIGHT + 54.5);
                      } else {
                          /*Circle around group*/
                          _ctx.beginPath();
                          _ctx.strokeStyle = COLORS[0];
                          _ctx.arc(state.x*TILEWIDTH+24,state.y*TILEHEIGHT+36.5,24,0,Math.PI*2);
                          _ctx.stroke();
                          /*Group info*/
                          _ctx.beginPath();
                          _ctx.fillStyle = COLORS[0];
                          _ctx.rect(state.x*TILEWIDTH + 22,state.y*TILEHEIGHT + 50.5,30,10);
                          _ctx.fill();
                          /* Action counter */
                          _ctx.beginPath();
                          _ctx.arc(state.x*TILEWIDTH + 6,state.y*TILEHEIGHT + 18.5,5,0,Math.PI*2);
                          _ctx.fill();
                          /*Info text*/
                          _ctx.fillStyle = COLORS[3];
                          _ctx.font = "bold 8px Arial"
                          _ctx.fillText(state.group + ": " + state.members.length,state.x*TILEWIDTH + 22.5,state.y*TILEHEIGHT + 58.5);
                          _ctx.fillText(state.actions,state.x*TILEWIDTH+3.25,state.y*TILEHEIGHT+21.5);
                      }
                      _ctx.globalAlpha = 1;
                    },
                    update: () => {
                      state.range = Math.ceil(state.members.length/10);
                      if (mouse.click == true && mouse.x > state.x*TILEWIDTH && mouse.x < state.x*TILEWIDTH + 48 && mouse.y > state.y*TILEWIDTH && mouse.y < state.y*TILEWIDTH + 45) {
                          if (enemy != true) {
                              /* Create action command list; only if player is enabled*/
                              if (enablePlayer == true && state.list == null && movingGroup == null && state.actions > 0 && message == false && menuActive == false && attackGroup == null && !fx.type && _tileSelector.open == false) {
                                  /* Delete all other group's lists, but be sure the group exists first.*/
                                  for (let i=0;i<groups.length;i++) {
                                      if (groups[i].list != null && groups[i].list.active == -1) {
                                          remove(groups[i].list);
                                          groups[i].list = null;
                                      }
                                      if (groups[i].list != null && groups[i].list.active != -1)
                                          return;
                                  }
                                  /* Disable click */
                                  mouse.click = false;
                                  //Old Code, used to bring up list
                                  //state.list = add(List(mouse.x - 5,mouse.y - 5,state));
                                  state.move();
                              }
                          }
                      }
                      if (state.goto != null) {
                          state.x += ((state.goto[0] - state.x)/3)*deltaTime;
                          state.y += ((state.goto[1] - state.y)/3)*deltaTime;
                          if (Math.round(state.x) == Math.round(state.goto[0]) && Math.round(state.y) == Math.round(state.goto[1]))
                              state.goto = null;
                      }
                      if (state.enemy == false) {
                          if (state.x > 240)
                              state.goto = [220,state.y];
                          else if (state.x < 0)
                              state.goto = [20,state.y];
                          if (state.y > 240)
                              state.goto = [state.x,220];
                          else if (state.y < 0)
                              state.goto = [state.x,20];
                      }
                    },
                    attack: (attacker) => {
                      enemyLength = state.members.length;
                      state.members.splice(0,attacker.members.length);
                      attacker.actions -= 1;
                      /* Attacking group also takes loses */
                      attacker.members.splice(0,enemyLength/2);
                      shuffleGroup(attacker,12);
                      shuffleGroup(state,12);
                      /* Delete dead groups */
                      if (state.members.length < 1){
                          state.fade(200,0,() => {
                            state.kill();
                          });
                      }
                      if (attacker.members.length < 1){
                          attacker.fade(200,0,() => {
                            attacker.kill();
                          });
                      }
                      //If both parties survived, allow the player to move away.
                      if (state.members.length > 1 && attacker.members.length > 1) {
                          //Indicate the player needs to move away.
                          return true;
                      }
                      /* If either group needs to be faded start a timer */
                      if (attacker.members.length < 1 || state.members.length < 1) {
                        add(Timer(300,() => {
                          /* Check player status */
                          playerAction();
                        }));
                      } else {
                        /* Check player status */
                        playerAction();
                      }
                    },
                    moveTo: (x,y,callBack,customTime) => {
                      let time = 400;
                      if (customTime)
                        time = customTime;
                      let speed = {
                        x: (x - state.x)/((time/1000)*60),
                        y: (y - state.y)/((time/1000)*60)
                      }
                      add(Timer(time,() => {
                        state.x = x;
                        state.y = y;
                        if (callBack)
                          callBack();
                      },() => {
                        state.x += speed.x*deltaTime;
                        state.y += speed.y*deltaTime;
                        if (speed.x > 0 && state.x > x || speed.x < 0 && state.x < x) {
                          state.x = x;
                        }
                        if (speed.y > 0 && state.y > y || speed.y < 0 && state.y < y) {
                          state.y = y;
                        }
                      }));
                    },
                    kill: () => {
                          remove(state);
                          if (state.enemy == true) {
                              for (let i=0;i<enemyGroups.length;i++) {
                                  if (enemyGroups[i].ID == state.ID)
                                      enemyGroups.splice(i,1);
                              }
                          } else {
                              for (let i=0;i<groups.length;i++) {
                                  if (groups[i].ID == state.ID)
                                      groups.splice(i,1);
                              }
                          }
                    },
                    split: (ammount) => {
                      let newGroup;
                      if (state.members.length < 2)
                          return;
                      _tileSelector.start(state.x,state.y,1,(pos) => {
                        /*Split the group, reposition and shuffle it*/
                        if (enemy == true) {
                            newGroup = pushGroup(state.x, state.y,true);
                        } else {
                            if (groups.length >= 4)
                                return;
                           newGroup = pushGroup(state.x, state.y);
                        }
                        newGroup.actions = state.actions;
                        newGroup.members = state.members.splice(ammount,ammount);
                        newGroup.moveTo(pos[0],pos[1], () => {
                          shuffleGroup(state,12);
                          shuffleGroup(newGroup,12);
                          state.actions -= 1;
                          newGroup.actions -= 1;
                          /* Check player status */
                          playerAction();
                        },200);
                      });
                    },
                    move: (range) => {
                      let limit = state;
                      let moveAgain = false;
                      //If no custom range is given use default, if a custom range is given, limit the movement.
                      if (range == null) {
                        range = state.range;
                      } else {
                        limit = null;
                      }
                      _tileSelector.start(state.x,state.y,range,(pos) => {
                        add(SplitSelector(state,(actionGroup) => {
                          //Check if enemy exists in position
                          for (let e=0; e < enemyGroups.length; e++) {
                            if (pos[0] == enemyGroups[e].x && pos[1] == enemyGroups[e].y) {
                              moveAgain = enemyGroups[e].attack(actionGroup);
                            }
                          }
                          //Check if selected self then rest
                          if (pos[0] == actionGroup.x && pos[1] == actionGroup.y) {
                            actionGroup.actions = 0;
                            playerAction();
                          } else {
                            actionGroup.moveTo(pos[0],pos[1], () => {
                              if (moveAgain) {
                                actionGroup.move(1);
                              } else {
                                actionGroup.actions -= 1;
                                playerAction();
                              }
                            },200)
                          }
                        }));
                      }, limit);
                    },
                    enemyAction: (callback) => {
                      /* This is the enemy AI
                          Priorities:
                          1) Move towards enemy
                          2) Attack when in range
                      */
                      /* Priority 1:
                      Move enemy towards player
                      Determine closest player and move maximum range towards it. Move just close enough to attack
                      Goal: Choose weakest and closest group to move towards and attack
                      */
                      /* Determine what to advance on */
                      let distances = [];
                      let target = null;
                      calculateTileLayout();
                      let path = null;
                      let blackList = [];

                      //Only compute a path if a player group exists
                      if (groups.length > 0) {
                        target = null;
                        for (let i=0; i < groups.length; i++) {
                            distances[i] = Math.sqrt(Math.pow(groups[i].x - state.x,2)+Math.pow(groups[i].y - state.y,2));
                            if (distances[i-1] && distances[i] < distances[i-1]) {
                                target = i;
                            } else if (distances[i-1] == undefined) {
                                target = 0;
                            }
                        }
                        /* Find paths all around target */
                        for (let i = 0; i < 4; i++) {
                          x2 = groups[target].x + 1 * (i%2) * (i-2); //-1 for i == 1, 1 for i == 3
                          y2 = groups[target].y + 1 * (Math.abs(2-i) - 1) //1 for i == 0, -1 for i == 2

                          let tempPath;
                          if (x2 < 5 && 0 <= x2 && y2 < 5 && 0 <= y2) {
                            tempPath = pathFind(state.x,state.y,x2,y2);
                            if (tempPath.length > 0) {
                              if (path == null || tempPath.length < path.length) {
                                path = tempPath;
                              }
                            }
                          }
                        }

                      }
                      /* Make sure target is worth going for and that the enemy can even still move*/
                      if (target != null && distances[target] > 1 && state.actions > 0 && path != null) {
                          let range = state.range;
                          let tileMovement = (i) => {
                            if (range > 0) {
                              state.moveTo(path[i].x,path[i].y, () => {
                                range--;
                                tileMovement(i + 1);
                              });
                            } else {
                              state.actions -= 1;
                              state.enemyAction(callback);
                            }
                          }
                          tileMovement(0);
                          return;
                      }

                      /* Priority 2
                      Attack the closest player group
                      */
                      if (state.actions > 0 && groups[target] && distances[target] == 1) {
                          state.actions -= 1;
                          let counter = groups[target].members.length;
                          groups[target].members.splice(0,state.members.length);

                          state.members.splice(0,counter / 2);

                          shuffleGroup(state,12);
                          shuffleGroup(groups[target],12);
                          /* Delete dead groups */
                          if (state.members.length < 1){
                              state.actions = 0;
                              state.fade(200,0,() => {
                                state.kill();
                              });
                          }
                          if (groups[target].members.length < 1){
                              groups[target].fade(200,0,() => {
                                groups[target].kill();
                              });
                          }
                          /* If either group needs to be faded start a timer */
                          if (groups[target].members.length < 1 || state.members.length < 1) {
                            add(Timer(300,() => {
                              state.enemyAction(callback);
                            }));
                          } else {
                            state.enemyAction(callback);
                          }
                          return;
                      }
                      /* Priority 3
                      Enemy can not do anything. Rest
                      */
                      state.actions = 0;
                      //All done with enemy's action. Return to main function.
                      if (callback)
                        callback();
                    },
                });

                /* Enemy status */
                if (enemy) {
                    state.enemy = enemy;
                    state.zIndex = 2;
                }

                return state;
            };

            const List = (x,y,group) => {
                let state = Object.assign(
                  GameObject(x,y),
                  {
                    zIndex: 99,
                    items: ["Split","Rest"],
                    active: null,
                    group,
                    inactive: [0,0,0,0,0],
                    draw: () => {
                      state.update();
                      _ctx.beginPath();
                      _ctx.fillStyle = COLORS[0];
                      _ctx.rect(state.x,state.y,50,70);
                      _ctx.fill();
                      if (state.active != -1 && state.inactive[state.active] == 0) {
                          _ctx.beginPath();
                          _ctx.fillStyle = COLORS[1];
                          _ctx.rect(state.x,state.y + state.active*(70/state.items.length),50,70/state.items.length);
                          _ctx.fill();
                      }
                      _ctx.fillStyle = COLORS[3];
                      _ctx.font = "bold 11px Arial"
                      for (let i=0;i<state.items.length;i++) {
                          if (state.inactive[i] == 1) {
                             _ctx.fillStyle = COLORS[1];
                          }
                          _ctx.fillText(state.items[i],state.x + 2,state.y + (70/state.items.length) * i + 11);
                          if (state.inactive[i] == 1) {
                             _ctx.fillStyle = COLORS[3];
                          }
                      }
                    },
                    update: () => {
                      if (mouse.x > state.x && mouse.x < state.x + 50 && mouse.y > state.y && mouse.y < state.y + 70) {
                          state.active = Math.floor((mouse.y - state.y) / (70/state.items.length));
                      } else {
                          state.active = -1;
                      }
                      if (mouse.click) {
                          mouse.click = false;
                          if (state.inactive[state.active] == 0) {
                              //Disable player after making selection
                              enablePlayer = false;
                              /* Split */
                              if (state.active == 0) {
                                  if (groups.length == 1) {
                                    state.group.split();
                                  } else {
                                    state.group.join();
                                  }
                              /* Move
                              } else if (state.active == 1) {
                                  state.group.move();
                              }
                              /* Build */
                            /* else if (state.active == 2) {
                                  add(BuildingMenu(state.group));
                              }
                              /* Attack
                              else if (state.active == 2) {
                                  attackGroup = group;
                              /* Rest */
                            } else if (state.active == 1) {
                                  state.group.actions = 0;
                                  /* Check player status */
                                  playerAction();
                              }
                          }
                          /* List is removed whether action occurs or not
                          Unless it is an inactive item
                          */
                          if (state.inactive[state.active] == 0 || state.active == -1) {
                              remove(state);
                              state.group.list = null;
                          }
                      }
                    }
                  }
                );

                /* If list is off screen, move it */
                if (state.x + 50 > 240) {
                    state.x -= 40;
                }
                if (state.y + 70 > 240) {
                    state.y -= 60;
                }

                let distance = null;
                let target = 0;
                /* disable attack if no enemies are nearby */
                for (let i=0; i < enemyGroups.length; i++) {
                    if (distance == null) {
                      distance = Math.sqrt(Math.pow(enemyGroups[i].x - group.x,2)+Math.pow(enemyGroups[i].y - group.y,2));
                    } else if (Math.sqrt(Math.pow(enemyGroups[i].x - group.x,2)+Math.pow(enemyGroups[i].y - group.y,2)) < distance) {
                      distance = Math.sqrt(Math.pow(enemyGroups[i].x - group.x,2)+Math.pow(enemyGroups[i].y - group.y,2));
                    }
                }
                if (distance > 1) {
                    state.inactive[3] = 1;
                }
                /* Change split to rejoin */
                if (groups.length > 1)
                    state.items[0] = "Join";
                /* Disable move,split, and build if group is blocked off */
                calculateTileLayout();
                if (tileCheck(group.x,group.y+1) !== 1 && tileCheck(group.x,group.y-1) !== 1 && tileCheck(group.x+1,group.y) !== 1 && tileCheck(group.x-1,group.y) !== 1) {
                    state.inactive[0] = 1;
                    /*state.inactive[1] = 1;
                    state.inactive[2] = 1;*/
                }

                return state;
            };

            const Message = (text,y,length,callBack) => {
                let state = Object.assign(
                  GameObject(0,y),
                  {
                    zIndex: 101,
                    text,
                    length: -1,
                    height: 0,
                    step: 1,
                    init: () => {
                      message = true;
                      add(Timer(250,() => {
                        state.step = 2;
                        if (state.length < 0) {
                          /* This message is click triggered */
                          return;
                        }
                        add(Timer(state.length, () => {
                          state.close();
                        }));
                      }, () => {
                        /* Step 1 Progress*/
                        state.height += (50/15)*deltaTime;
                        state.y -= (25/15)*deltaTime;
                      }));
                    },
                    close: () => {
                      state.step = 3;
                      add(Timer(250, () => {
                        /* Finish */
                        message = false;
                        remove(state);
                        state.draw = null;
                        if (callBack)
                            callBack();
                      }, () => {
                        /* Step 3 progress */
                        state.height -= (50/15)*deltaTime;
                        state.y += (25/15)*deltaTime;
                      }));
                    },
                    draw: () => {
                      message = true;
                      _ctx.fillStyle = COLORS[0];
                      _ctx.beginPath();
                      _ctx.rect(0,state.y,240,state.height);
                      _ctx.fill();
                      if (state.step == 2) {
                          _ctx.fillStyle = COLORS[3];
                          _ctx.font = "bold 24px Arial"
                          _ctx.fillText(state.text,10,state.y + 35);
                          if (state.length < 0 && mouse.click)
                            state.close();
                      }
                    },
                  }
                );

                /* How long should the message appear for */
                if (length)
                    state.length = length;

                /* Start timer */
                state.init();

                return state;
            };

            /* Simple timer */
            const Timer = (time,callBack,progress) => {
              let state = Object.assign(
                GameObject(0,0),
                {
                  time: Date.now() + time,
                  disable: false,
                  draw: () => {
                    /* If progress callBack */
                    if (Date.now() >= state.time && state.disable == false) {
                      remove(state);
                      state.disable = true;
                      if (callBack)
                        callBack();
                    }
                    if (progress && state.disable == false)
                      progress();
                  }
                }
              );
              return state;
            };

            /* The target sprite (targets any sprite for a specified time) */
            const Target = (sprite,time,callBack, offset) => {
              let state = Object.assign(
                GameObject(sprite.x,sprite.y),
                {
                  zIndex: 100,
                  alpha: 0,
                  offset: {x: 0, y: 0},
                  draw: () => {
                    _ctx.globalAlpha = state.alpha;
                    /* Draw target around sprite */
                    _ctx.drawImage(graphics,16*6,16,16,16,sprite.x*TILEWIDTH + 1 + state.offset.x,sprite.y*TILEHEIGHT + 14 + state.offset.y,16,16);
                    _ctx.drawImage(graphics,0,16*2,16,16,sprite.x*TILEWIDTH + 31 + state.offset.x,sprite.y*TILEHEIGHT + 14 + state.offset.y,16,16);
                    _ctx.drawImage(graphics,16,16*2,16,16,sprite.x*TILEWIDTH + 31 + state.offset.x,sprite.y*TILEHEIGHT + 44 + state.offset.y,16,16);
                    _ctx.drawImage(graphics,16*2,16*2,16,16,sprite.x*TILEWIDTH + 1 + state.offset.x,sprite.y*TILEHEIGHT + 44 + state.offset.y,16,16);

                    _ctx.globalAlpha = 1;
                  },
                  update: () => {

                  },
                  init: () => {
                    if (offset)
                      state.offset = offset;
                    state.fade(time/8,1);
                    add(Timer(time/4,() => {
                      state.fade(time/4,0);
                      add(Timer(time/4,() => {
                        state.fade(time/8,1);
                        add(Timer(time/4,() => {
                          state.fade(time/4,0);
                          add(Timer(time/4,() => {
                            remove(state);
                            if (callBack)
                              callBack();
                          }));
                        }));
                      }));
                    }));
                  }
                }
              );
              state.init();

              return state;
            }

            /* Tile select */
            const TileSelect = () => {
              let state = Object.assign(
                GameObject(0,0),
                {
                  tiles: [],
                  callBack: null,
                  alphaSpeed: .01,
                  open: false,
                  start: (x,y,range,callBack,player) => {
                    state.open = true;
                    if (callBack) {
                      state.callBack = callBack;
                    } else {
                      state.callBack = null;
                    }
                    add(state);
                    state.tiles = [];
                    state.calculateTiles(x,y,range);
                    state.tiles = uniq_fast(state.tiles);
                    /* Check the layout of the grid */
                    calculateTileLayout(player);
                    for (let i=0;i<state.tiles.length;i++) {
                      if (state.tiles[i][0] > 4 || state.tiles[i][1] > 4) {
                        state.tiles.splice(i,1);
                        i--;
                      } else if (tileCheck(state.tiles[i][0],state.tiles[i][1]) != 1) {
                        state.tiles.splice(i,1);
                        i--;
                      }
                    }
                  },
                  calculateTiles: (x,y,range) => {
                    if (range == 0) {
                      state.tiles.push([x,y]);
                      return;
                    }
                    state.tiles.push([x,y]);
                    state.calculateTiles(x-1,y,range-1);
                    state.calculateTiles(x+1,y,range-1);
                    state.calculateTiles(x,y+1,range-1);
                    state.calculateTiles(x,y-1,range-1);
                  },
                  draw: () => {
                    state.update();
                    /* Fade effect */
                    state.alpha += state.alphaSpeed*deltaTime;
                    if (state.alpha < .4) {
                      state.alpha = .4;
                      state.alphaSpeed = -state.alphaSpeed;
                    } else if (state.alpha > .8) {
                      state.alpha = .8;
                      state.alphaSpeed = -state.alphaSpeed;
                    }
                    for (let i=0;i<state.tiles.length;i++) {
                      _ctx.beginPath();
                      _ctx.strokeStyle = COLORS[3];
                      _ctx.fillStyle = COLORS[2];
                      _ctx.rect(state.tiles[i][0]*TILEWIDTH,state.tiles[i][1]*TILEHEIGHT+14,48,45);
                      _ctx.globalAlpha = state.alpha;
                      _ctx.fill();
                      _ctx.globalAlpha = 1;
                      _ctx.stroke();
                    }
                  },
                  update: () => {
                    if (mouse.click) {
                      for (let i=0; i<state.tiles.length; i++) {
                        if (mouse.x > state.tiles[i][0]*TILEWIDTH && mouse.x < state.tiles[i][0]*TILEWIDTH + TILEWIDTH && mouse.y > state.tiles[i][1]*TILEHEIGHT+14 && mouse.y < state.tiles[i][1]*TILEHEIGHT+14+TILEHEIGHT) {
                          /* Player has clicked on a valid tile */
                          remove(state);
                          state.open = false;
                          mouse.click = false;
                          if (state.callBack)
                            state.callBack(state.tiles[i]);
                        }
                      }
                    }
                  }
                }
              );

              return state;
            }


            function pushGroup(x,y,enemy) {
                let newGroup = add(Group(x, y,enemy));
                if (enemy == true) {
                    enemyGroups.push(newGroup);
                } else {
                    groups.push(newGroup);
                    newGroup.group = String.fromCharCode(65 + groups.length-1);
                }
                return newGroup;
            }

            function add(obj,last) {
                obj.ID = objId++;
                objects.push(obj);
                return obj;
            }

            function remove(obj) {
                if (obj.ID != null)
                    for (let i=0;i<objects.length;i++) {
                        if (obj.ID == objects[i].ID) {
                            objects.splice(i,1);
                            obj.ID = null;
                            draw();
                            return obj;
                        }
                    }
                return null;
            }

            /*Game Start Code*/
            function gameStart() {
                _tileSelector = TileSelect();
                switchState(MENU_STATE);
                bgDraw();
            }

            function switchState(newState) {
                objects = [];
                groups = [];
                enemyGroups = [];
                whichEnemy = 0;
                movingGroup = null;
                attackGroup = null;
                targetedSprite = null;
                message = false;
                buildings = [];
                menuActive = false;
                enablePlayer = false;
                _canvas.style.cursor = "default";
                _tileLayout = [];
                gameState = newState;
            }

            function beginLevel() {
                switchState(GAME_STATE);
                turn = "player";
                /* Switch background */
                bgDraw();
                /* Start turn after flash */
                startFX(FLASH,{complete: () => {
                    if (gameState == GAME_STATE)
                        turnSwitch(true);
                }, time: 20});
                if (level == 0) {
                    /* Create player */
                    shuffleGroup(createTroops(20,0,0,pushGroup(3,3)),12)
                    /* Create Enemies */
                    shuffleGroup(createTroops(10,0,0,pushGroup(1,1,true)),12);
                    shuffleGroup(createTroops(7,0,0,pushGroup(1,3,true)),12);
                    shuffleGroup(createTroops(7,0,0,pushGroup(4,4,true)),12);
                } else if (level == 1) {
                    shuffleGroup(createTroops(10,0,0,pushGroup(3,4)),12);
                    shuffleGroup(createTroops(10,0,0,pushGroup(1,0)),12);
                    shuffleGroup(createTroops(5,0,0,pushGroup(2,3,true)),12);
                    shuffleGroup(createTroops(15,0,0,pushGroup(0,0,true)),12);
                } else if (level == 2) {
                    //Players
                    shuffleGroup(createTroops(50,0,0,pushGroup(100,50)),12);
                    //Enemies
                    shuffleGroup(createTroops(70,0,0,pushGroup(-50,300,true)),12);
                } else {
                    /* PANIC! This is an error. Just reset game */
                    gameStart();
                }
            }

            function turnSwitch(player) {
                if (player == true) {
                    turn = "buildings";
                    add(Message("PLAYER TURN",120,750,buildingsActions));
                    /* Reset all groups */
                    for (let i=0;i<groups.length;i++) {
                        if (groups[i])
                          groups[i].actions = 3;
                    }
                    calculateTileLayout();
                } else {
                    whichEnemy = 0;
                    turn = "enemy";
                    add(Message("ENEMY TURN",120,750,enemyActions));
                    for (let i=0;i<enemyGroups.length;i++) {
                        if (enemyGroups[i])
                            enemyGroups[i].actions = 3;
                    }
                }
            }

            function createTroops(num,x,y,group) {
                for (let i=0;i<num;i++) {
                    if (group.enemy == true) {
                        group.members.push(Troop(x,y,6));
                    } else {
                        group.members.push(Troop(x,y,Math.floor(Math.random() * 6)));
                    }
                }
                return group;
            }

            /* Fun extra visual function (can be cut for more space) */
            function shuffleGroup(group,magnitude) {
                for (let i=0;i<group.members.length;i++) {
                    group.members[i].goto = [Math.random() * (magnitude*2) - magnitude,Math.random() * (magnitude*2) - magnitude]
                }
                return group;
            }

            /* Visual flare to indicate that sprite is active */
            function targetSprite(obj, time, callBack, offset) {
              add(Target(obj,time,callBack, offset));
            }

            /*Return the value of a tile space */
            function tileCheck(x,y) {
              if (x >= 0 && x < 5 && y >= 0 && y < 5) {
                  return _tileLayout[x][y];
              } else {
                  return null;
              }
            }

            function calculateTileLayout(player) {
              for (let i = 0; i < 5; i++) {
                _tileLayout[i] = [];
                for (let j = 0; j < 5; j++) {
                  _tileLayout[i][j] = 1;
                }
              }
              for (let i = 0; i < groups.length; i++) {
                if (player) {
                  _tileLayout[groups[i].x][groups[i].y] = 1;
                } else {
                  _tileLayout[groups[i].x][groups[i].y] = 0;
                }
              }
              for (let i = 0; i < enemyGroups.length; i++) {
                if (player && player.actions > 1) {
                  _tileLayout[enemyGroups[i].x][enemyGroups[i].y] = 1;
                } else {
                  _tileLayout[enemyGroups[i].x][enemyGroups[i].y] = 0;
                }
              }
              for (let i = 0; i < buildings.length; i++) {
                _tileLayout[buildings[i].tile[0]][buildings[i].tile[1]] = 0;
              }
              //For water tiles
              for (var r=0;r<5;r++) {
                  for (var c=0;c<5;c++) {
                      if (levelData[level][r][c] != 0) {
                          _tileLayout[c][r] = 0;
                      }
                  }
              }
            }

            function pathFind(x1,y1,x2,y2) {
              let graph = new Graph(_tileLayout);
            	let start = graph.grid[x1][y1];
            	let end = graph.grid[x2][y2];
            	return astar.search(graph, start, end);
            }

            function sortObjects() {
                /* Sort buildings */
                let error = false;
                if (buildings)
                  do {
                      error = false;
                      for (let i=0;i<buildings.length-1;i++) {
                          if (buildings[i].y < buildings[i+1].y) {
                              let temp = buildings[i];
                              buildings[i] = buildings[i+1];
                              buildings[i+1] = temp;
                              error = true;
                          }
                          buildings[i].zIndex = 1 - i/10;
                      }
                  } while (error == true);

                /* Sort every other sprite */
                do {
                    error = false;
                    for (let i=0;i<objects.length-1;i++) {
                        if (objects[i].zIndex > objects[i+1].zIndex) {
                            let temp = objects[i];
                            objects[i] = objects[i+1];
                            objects[i+1] = temp;
                            error = true;
                        }
                    }
                } while (error == true);
            }

            /* return an array with all unique values */
            function uniq_fast(a) {
                let seen = {};
                let out = [];
                let len = a.length;
                let j = 0;
                for(let i = 0; i < len; i++) {
                     let item = a[i];
                     if(seen[item] !== 1) {
                           seen[item] = 1;
                           out[j++] = item;
                     }
                }
                return out;
            }

            function gameLoop() {
              requestAnimationFrame(gameLoop);

              /* Calculate Deltatime */
              deltaTime = (Date.now() - _lastTime)/(1000/60);
              _lastTime = Date.now();

              /* STATE MANAGER */
              if (gameState == GAME_STATE) {
                  if (turn == "enemy")
                      mouse.click = false;
                  else if (turn == "player")
                      gameUpdate();
                  else if (turn == "buildings")
                      mouse.click = false;
              } else if (gameState == MENU_STATE) {
                  menuUpdate();
              }

              /* Draw Function */
              draw();

              /*Release mouse click event*/
              mouse.click = false;
            }

            function draw() {
                sortObjects();
                _ctx.clearRect(0,0,480,480);
                //Draw background
                _ctx.drawImage(_bgCanvas,0,0,240,240);
                /*Sprites*/
                for (let i=0;i<objects.length;i++) {
                    objects[i].draw();
                }

                /*Game State specific stuff */
                if (gameState == GAME_STATE) {
                    /* HUD */
                    _ctx.fillStyle = COLORS[1];
                    _ctx.strokeStyle = COLORS[0];
                    _ctx.beginPath();
                    _ctx.rect(-2,-2,244,15);
                    _ctx.fill();
                    _ctx.stroke();
                    _ctx.textAlign = "center";
                    let txt;
                    if (movingGroup != null) {
                        txt = "Moving Group";
                    } else if (attackGroup != null) {
                        txt = "Select Enemy Group to Attack"
                    } else if (turn == "player" || turn == "buildings") {
                        txt = "Player's Turn";
                    } else if (turn == "enemy") {
                        txt = "Enemy's Turn";
                    } else {
                        txt = "";
                    }
                    _ctx.font = "bold 8px Arial";
                    _ctx.fillStyle = COLORS[3];
                    _ctx.fillText(txt,120,9);
                    _ctx.textAlign = "left";
                } else if (gameState == MENU_STATE) {
                    /*Sine wave*/
                    let flag = {x: 25, y: 90,period: 1.5,size: 50,width:80,wave: 5};
                    flag.y = flag.y - flag.wave*Math.sin((((sineOffset)/flag.width-1)*(Math.PI*2))/flag.period);
                    _ctx.beginPath();
                    _ctx.fillStyle = COLORS[3];
                    for (let s=0;s<2;s++) {
                        if (s==0)
                            _ctx.moveTo(flag.x,(flag.y + s*flag.size)+flag.wave*Math.sin((((sineOffset)/flag.width-1)*(Math.PI*2))/flag.period));
                        else if (s==1)
                            _ctx.lineTo(flag.x+flag.width-1,flag.y+flag.size + flag.wave*Math.sin((((sineOffset+flag.width-1)/flag.width-1)*(Math.PI*2))/flag.period));
                        for (let i=0;i<flag.width;i++) {
                            if (s==0)
                                _ctx.lineTo(flag.x+i,(flag.y + s*flag.size)+flag.wave*Math.sin((((i+sineOffset)/flag.width-1)*(Math.PI*2))/flag.period));
                            if (s==1)
                                _ctx.lineTo(flag.x+flag.width-1-i,(flag.y + s*flag.size)+flag.wave*Math.sin((((flag.width-i+sineOffset)/flag.width-1)*(Math.PI*2))/flag.period));
                        }
                    }
                    _ctx.closePath();
                    _ctx.fill();
                    sineOffset -= deltaTime;
                }

                /* If fx are active then draw them */
                if (fx != {}) {
                    fxDraw();
                }
            }

            /* Run this function if all the player groups die */
            function gameOver() {
                turn = "gameOver";
                add(Message("GAME OVER!",120,-1, () => {
                    startFX(FADE,{complete: () => {
                      switchState(MENU_STATE);
                      bgDraw();
                      startFX(FLASH,{time: 20});
                    }, time: 20});
                }));
            }

            function win() {
                turn = "win";
                level++;
                add(Message("STAGE CLEAR",120,-1, () => {
                    startFX(FADE,{complete: beginLevel, time: 20});
                }));
            }

            function gameUpdate() {

            }

            /* Call once to enable player actions */
            function playerAction() {
              /* Check if player groups are still alive */
              let alive = false;
              for (let i=0;i<groups.length;i++) {
                  if (groups[i] != null)
                      alive = true
              }
              if (alive == false) {
                  gameOver();
                  return;
              }
              /* Check if enemy groups are still alive */
              alive = false;
              for (let i=0;i<enemyGroups.length;i++) {
                  if (enemyGroups[i] != null)
                      alive = true
              }
              if (alive == false) {
                  win();
                  return;
              }
              /* End turn when all actions are used up */
              if (groups && turn == "player")
                  if (groups.length > 0) {
                      let totalActions = 0;
                      for (let i=0;i<groups.length;i++)
                          if (groups[i])
                              totalActions += groups[i].actions;
                      if (totalActions == 0)
                          turnSwitch(false);
                  }

              /* If the player can move the enable them */
              enablePlayer = true;
            }

            function buildingsActions() {
                if (currentBuilding == buildings.length) {
                  /* Once all building actions are complete switch control to player and reset buildings*/
                  currentBuilding = 0;
                  turn = "player";
                  playerAction();
                } else {
                  buildings[currentBuilding].action();
                  currentBuilding++;
                }
            }

            /* Create for loop to select enemy who has actions left.
            Don't use whichEnemy as a counter! */
            function enemyActions() {
                whichEnemy = 0;
                for (let i=0; i<enemyGroups.length; i++) {
                  if (enemyGroups[i].actions > 0) {
                    whichEnemy = i;
                    break;
                  }
                }
                targetSprite(enemyGroups[whichEnemy],1000,() => {
                  enemyGroups[whichEnemy].enemyAction(() => {
                    whichEnemy++;

                    /* Check to see if there are any players still standing */
                    if (groups.length == 0) {
                        gameOver();
                        return;
                    }

                    /* Check if enemy groups are still alive */
                    if (enemyGroups.length == 0) {
                        win();
                        return;
                    }

                    for (let i=0; i<enemyGroups.length; i++) {
                      if (enemyGroups[i].actions > 0) {
                        enemyActions()
                        return;
                      }
                    }
                    /* end turn if no more enemies can move */
                    whichEnemy = 0;
                    turnSwitch(true);
                });
              });
            }

            /* Update logic for the main menu */
            function menuUpdate() {
                /* Click the start button */
                if (mouse.x > 165 -52 && mouse.x < 165+52 && mouse.y > 168 && mouse.y < 202) {
                    _canvas.style.cursor = "pointer";
                    if (mouse.click && !fx.type) {
                        level = 0;
                        startFX(CIRCLE_TRANSITION,{complete: beginLevel});
                        _canvas.style.cursor = "default";
                    }
                } else {
                    _canvas.style.cursor = "default";
                }
            }

            /*
                Types and Options:
                1) Circle Transition:
                    - Speed
                    - Density
                    - Complete
                2) Fade
                    - Color
                    - Time
                    - Complete
                3) Flash
                    - Color
                    - Time
                    - Complete
            */
            function startFX(type,options) {
                fx = {type: type, options: options};
                if (type == CIRCLE_TRANSITION) {
                    if (options.density == null)
                        options.density = 5;
                    if (options.speed == null)
                        options.speed = 5;
                    fx.circles = [];
                    /* Build the 2d array */
                    for (let i=0;i<options.density;i++)
                        fx.circles[i] = [];
                    /* p = y cord, i = x cord */
                    for (let p=0;p<options.density;p++)
                        for (let i=0;i<options.density;i++)
                            fx.circles[i][p] = 0;

                    fx.radius = 0;
                }
                if (type == FADE) {
                    if (options.color == null)
                        options.color = COLORS[0];
                    if (options.time == null)
                        options.time = 100;
                    fx.opacity = 0;
                }
                if (type == FLASH) {
                    if (options.color == null)
                        options.color = COLORS[0];
                    if (options.time == null)
                        options.time = 100;
                    fx.opacity = 1;
                }
            }

            function fxDraw() {
               if (fx.type === CIRCLE_TRANSITION) {
                   /* p = y cord, i = x cord */
                   let separation = 240 / fx.options.density;
                   let finished = true;
                    for (let p=0;p<fx.options.density;p++)
                        for (let i=0;i<fx.options.density;i++) {
                            /* Don't grow circles forever */
                            if (fx.circles[i][p] < separation) {
                                finished = false;
                            }
                            if (Math.sqrt(Math.pow(p*separation-120+separation/2,2)+Math.pow(i*separation-120+separation/2,2)) <= fx.radius) {
                                fx.circles[i][p]++;
                            }
                            /* If the circle's radius is more than 0 draw it*/
                            if (fx.circles[i][p] > 0) {
                                _ctx.fillStyle = COLORS[0];
                                _ctx.beginPath()
                                _ctx.arc(i*separation+separation/2,p*separation+separation/2,fx.circles[i][p],0,Math.PI*2);
                                _ctx.fill();
                            }
                        }
                    fx.radius+= fx.options.speed;
                   if (finished == true) {
                       let complete = fx.options.complete;
                       fx = {}
                       if (complete)
                           complete();
                   }
                }
                /* Fade transition */
                else if (fx.type == FADE) {
                    _ctx.beginPath();
                    _ctx.globalAlpha = fx.opacity;
                    _ctx.fillStyle = fx.options.color;
                    _ctx.rect(0,0,WIDTH/2,HEIGHT/2);
                    _ctx.fill();
                    _ctx.globalAlpha = 1;
                    fx.opacity += 1/fx.options.time;
                    /* When complete */
                    if (fx.opacity >= 1) {
                        let complete = fx.options.complete;
                        fx = {}
                        if (complete)
                            complete();
                    }
                }
                /* Flash effect */
                else if (fx.type == FLASH) {
                    _ctx.beginPath();
                    _ctx.globalAlpha = fx.opacity;
                    _ctx.fillStyle = fx.options.color;
                    _ctx.rect(0,0,WIDTH/2,HEIGHT/2);
                    _ctx.fill();
                    _ctx.globalAlpha = 1;
                    fx.opacity -= 1/fx.options.time;
                    /* When complete */
                    if (fx.opacity <= 0) {
                        let complete = fx.options.complete;
                        fx = {}
                        if (complete)
                            complete();
                    }
                }
            }

            /* Background layer doesn't have to be drawn every frame */
            function bgDraw() {
                _bgCtx.clearRect(0,0,480,480);
                if (gameState == GAME_STATE) {
                    /*Background*/
                    for (var r=0;r<5;r++) {
                        for (var c=0;c<5;c++) {
                            if (levelData[level][r][c] == 0) {
                                _bgCtx.drawImage(_tiles,0,0,TILEWIDTH,TILEHEIGHT,c*TILEWIDTH,r*45 + 14,TILEWIDTH,TILEHEIGHT+1);
                            }
                            else if (levelData[level][r][c] == 1) {
                                _bgCtx.drawImage(_tiles,TILEWIDTH,0,TILEWIDTH,TILEHEIGHT,c*TILEWIDTH,r*45 + 14,TILEWIDTH,TILEHEIGHT+1);
                            }
                            else if (levelData[level][r][c] == 2) {
                                _bgCtx.drawImage(_tiles,TILEWIDTH*2,0,TILEWIDTH,TILEHEIGHT,c*TILEWIDTH,r*45 + 14,TILEWIDTH,TILEHEIGHT+1);
                            }
                        }
                    }
                    /* Draw grid */
                    /*for (let i = 0; i < 6; i++) {
                      _bgCtx.beginPath();
                      _bgCtx.moveTo(i*TILEWIDTH,0);
                      _bgCtx.lineTo(i*TILEWIDTH,HEIGHT/2);
                      _bgCtx.stroke();
                    }
                    for (let i = 0; i < 6; i++) {
                      _bgCtx.beginPath();
                      _bgCtx.moveTo(0,i*TILEHEIGHT + 14);
                      _bgCtx.lineTo(WIDTH/2,i*TILEHEIGHT + 14);
                      _bgCtx.stroke();
                    }*/
                } else if (gameState == MENU_STATE) {
                    /* Title Menu */
                    /* Background */
                    _bgCtx.fillStyle = COLORS[1];
                    _bgCtx.beginPath();
                    _bgCtx.rect(0,0,240,120);
                    _bgCtx.fill();
                    _bgCtx.fillStyle = COLORS[2];
                    _bgCtx.beginPath();
                    _bgCtx.rect(0,120,240,120);
                    _bgCtx.fill();
                    /* Sun (even though it looks like a moon)*/
                    _bgCtx.fillStyle = COLORS[3];
                    _bgCtx.beginPath();
                    _bgCtx.arc(200,43,25,0,Math.PI*2);
                    _bgCtx.fill();
                    /*Castle Begin*/
                    _bgCtx.fillStyle = COLORS[0];
                    _bgCtx.beginPath();
                    _bgCtx.rect(100,70,130,70);
                    _bgCtx.fill();
                    _bgCtx.beginPath();
                    _bgCtx.rect(100,50,20,20);
                    _bgCtx.fill();
                    _bgCtx.beginPath();
                    _bgCtx.rect(100,50-20/3,20/3,20/3);
                    _bgCtx.fill();
                    _bgCtx.beginPath();
                    _bgCtx.rect(100+40/3,50-20/3,20/3,20/3);
                    _bgCtx.fill();
                    _bgCtx.beginPath();
                    _bgCtx.rect(210,50-20/3,20/3,20/3);
                    _bgCtx.fill();
                    _bgCtx.beginPath();
                    _bgCtx.rect(210+40/3,50-20/3,20/3,20/3);
                    _bgCtx.fill();

                    _bgCtx.beginPath();
                    _bgCtx.rect(165-15,20,30,50);
                    _bgCtx.fill();

                    _bgCtx.beginPath();
                    _bgCtx.rect(165-15,20-30/3,30/3,30/3);
                    _bgCtx.fill();

                    _bgCtx.beginPath();
                    _bgCtx.rect(165-15 + 60/3,20-30/3,30/3,30/3);
                    _bgCtx.fill();

                    /*Right Arm*/
                    _bgCtx.beginPath();
                    _bgCtx.moveTo(180,50);
                    _bgCtx.lineTo(190,40);
                    _bgCtx.lineTo(190,20);
                    _bgCtx.lineTo(200,20);
                    _bgCtx.lineTo(200,50);
                    _bgCtx.lineTo(180,60);
                    _bgCtx.closePath();
                    _bgCtx.fill();
                    /* Left Arm */
                    _bgCtx.beginPath();
                    _bgCtx.moveTo(150,50);
                    _bgCtx.lineTo(140,40);
                    _bgCtx.lineTo(140,20);
                    _bgCtx.lineTo(130,20);
                    _bgCtx.lineTo(130,50);
                    _bgCtx.lineTo(150,60);
                    _bgCtx.closePath();
                    _bgCtx.fill();

                    _bgCtx.beginPath();
                    _bgCtx.rect(210,50,20,20);
                    _bgCtx.fill();

                    /*Flag pole*/
                    _bgCtx.beginPath();
                    _bgCtx.rect(20,85,5,130);
                    _bgCtx.fill();

                    /* Start Button */
                    let bP = {x: 165 - 50, y: 170}
                    _bgCtx.strokeStyle = COLORS[3];
                    _bgCtx.lineWidth = 2;
                    _bgCtx.fillStyle = COLORS[2];
                    _bgCtx.beginPath();
                    _bgCtx.rect(bP.x,bP.y,100,30);
                    _bgCtx.fill();
                    _bgCtx.stroke();
                    _bgCtx.fillStyle = COLORS[1];
                    _bgCtx.beginPath();
                    _bgCtx.rect(bP.x - 1,bP.y + 31,102,5);
                    _bgCtx.fill();
                    _bgCtx.fillStyle = COLORS[1];
                    _bgCtx.textAlign = "center";
                    _bgCtx.font = "bold 18px Arial";
                    _bgCtx.fillText("Start",bP.x + 50,bP.y + 22);

                    /*Title text*/
                    _bgCtx.shadowColor = COLORS[2];
                    _bgCtx.shadowOffsetY = 2;
                    _bgCtx.font = "bold 32px Arial";
                    _bgCtx.textAlign = "center";
                    _bgCtx.fillStyle = COLORS[3];
                    _bgCtx.fillText("Split",47,33);
                    _bgCtx.fillText("Army",47,63);
                    _bgCtx.shadowOffsetY = 0;
                }
            }

            /* Extra Stuff */
            document.getElementById("f").onclick = () => {
                if (fullscreen == false) {
                    if (_gameDiv.webkitRequestFullscreen)
                        _gameDiv.webkitRequestFullscreen();
                    if (_gameDiv.requestFullscreen)
                        _gameDiv.requestFullscreen();
                    if (_gameDiv.mozRequestFullScreen)
                        _gameDiv.mozRequestFullScreen();
                    if (_gameDiv.msRequestFullscreen)
                        _gameDiv.msRequestFullscreen();
                } else {
                    if (document.exitFullscreen)
	                   document.exitFullscreen();
                    if (document.webkitExitFullscreen)
                        document.webkitExitFullscreen();
                    if (document.mozCancelFullScreen)
                        document.mozCancelFullScreen();
                    if (document.msExitFullscreen)
                        document.msExitFullscreen();
                }
            }
            /* Resize Canvas for fullscreen-ness */
            function FShandler() {
                let canvases = _gameDiv.childNodes;
                if (fullscreen == false) {
                    fullscreen = true;
                    if (window.screen.width > window.screen.height) {
                        _gameDiv.style.height = screen.height;
                        //_gameDiv.style.width = screen.height;
                        _gameDiv.style.width = screen.width;
                        _gameDiv.style.margin = "auto";
                        for (var i=0; i<canvases.length;i++){
                            //canvases[i].style.width = screen.height;
                            canvases[i].style.width = screen.width;
                            canvases[i].style.height = screen.height;
                            //if (_gameDiv.offsetWidth > screen.height)
                                //canvases[i].style.left = screen.width/2 - screen.height/2;
                        }
                    } else {
                        _gameDiv.style.width = screen.width;
                        //_gameDiv.style.height = screen.width;
                        _gameDiv.style.height = screen.height;
                        _gameDiv.style.margin = "auto";
                        for (var i=0; i<canvases.length;i++){
                            canvases[i].style.width = screen.width;
                            //canvases[i].style.height = screen.width;
                            canvases[i].style.height = screen.height;
                            //if (_gameDiv.offsetHeight > screen.width)
                                //canvases[i].style.top = screen.height/2 - screen.width/2;
                        }
                    }
                } else {
                    fullscreen = false;
                    _gameDiv.style.width = _canvas.width;
                    _gameDiv.style.height = _canvas.height;
                    _gameDiv.style.margin = 0;
                    for (let i=0; i<canvases.length;i++){
                            canvases[i].style.width = _canvas.width;
                            canvases[i].style.height = _canvas.width;
                            canvases[i].style.left = 0;
                            canvases[i].style.top = 0;
                    }
                }
            }
            document.addEventListener("fullscreenchange", FShandler);
            document.addEventListener("webkitfullscreenchange", FShandler);
            document.addEventListener("mozfullscreenchange", FShandler);
            document.addEventListener("MSFullscreenChange", FShandler);

            document.onmousemove =  (e) => {
                let rect = _canvas.getBoundingClientRect();
                mouse.x = Math.round((e.clientX-rect.left)/(rect.right-rect.left)*_canvas.width/2);
                mouse.y = Math.round((e.clientY-rect.top)/(rect.bottom-rect.top)*_canvas.height/2);
            }
            document.onmousedown = (e) => {mouse.down = true; mouse.click = true;}
            document.onmouseup = (e) => {mouse.down = false;}
            document.addEventListener("touchstart", (e) => {mouse.down = false; mouse.click = true;}, false);
            document.addEventListener("touchend", (e) => {mouse.down = true;}, false);

            /*Start game*/
            gameLoop();
            gameStart();
        }
    </script>
</html>
<!--
opengameart.org
Videlais for the tile sheet
darkagent for players and enemies

lospec.com
Kirokaze for Pallet
!-->
<img id="g" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAAAwCAYAAADJuP4nAAAG5ElEQVR4nO1aQUskRxT+KqyHgIeFIXvJLt5lBGGEZU5zWDGY2agDEQKjEGUgB/uQvcVfsMe99B4WBhXGgcCE6MZMRHEPc5IcBgIZcl+MezARchAkeKgcZqqtrn5VXd3Trc7ED6R7qqqrXtdX772vqgXucY973B4Y59xfwNgtmXKNXHaBAwgYkikX+OH6i9gGqu8qwBgD5xyMMeSyC7zd2SXHMNXdFh7oKibHi/y3P5pMXG06y2UXxC01UwwA2p1dW9sCfZzXW7bPRoJKHkWUqU6H3kIEAKRFPEng5HiRP1qexgymOQBM1mBNosDOsevdl/JObANX9i+wOTvqXW0w8/JVgHyT54qoI00ykydflCltSMiLOFMuoOosouI2kKvDiyphi5gYWztugMDJ8SIZZyJ4IgeAitugym0XAYPBi8Mwt9QMlB2uW47cBQeATLkAwPP8KPZzAKg6i/jx7yVUnW2ULPvIZRe4vPgFSnmQnq8NoWe1I0tbaSQV7oTX2XofAMw93AqUOXgcadxMueC9g3wf5XldfzroyAO6EY0iUUvgo+VpnNWOvKslfCtXRsRVTKsNyxVMhWydMEoKIo9Csr3iNlB1ttVoFGoHZb+O2I/UAhEmBWniGjUHAnQoC0Muu8DFAsiUC96f+E3lBwUM6OZO+YoI5LU7u0z2lvN6K6oIYef1Fs7rLZTyDsS9rQ2U9+oQIBAIkhWHPAD4absY57FEECf0ChDeSokaD6qK7YkUBvgmn7U7uxBK1jR+1Vn0Ld6qs6htGwihPRXFZdZz9REuDLBBEvlPzRmmVWh6Pk7+Ajyl6JEoqUtbcMA3F6Ghs93ZZaU8+M6xGyCtlHfIKEDlQG91zC01ZS9KNYcA1+GTmnBZUOTqtCIDuhM/8/KVj7xMuYDD9RfWdqj7vagbePEeVWcRpbyDnWPX20qE9SNIpMqp9loRA8QKgTr5L9eTyGUXeDdfNbFZH1X7YgDUei0E2eo1CuQJu6nTFxFal/f+wS/fz3vln3/1FviiW2etQhMIg/JAxvwxNVHiO8cu5p5+g8rBv8Jz5Gd4V0Y7WNm/CPXCu4KK20CmXKD2xAHIW4jue14LwM3Zh7iu8783KWJ6YNLfbaGf8ZlyTQ3ESQ6Arhg5qx0F8pntwrMRYJQH9nUKEhW9l2dzT6+8Mc9qR6ry9eWFGLL+RtHu7LLJ2hWv9H5X3Ab1ToFnxDtKWx+I32JvqL43o84No+Dgu299HU5NlLBz7Nr0yeQNq+0zT0Y/1VaeXJxyOVwJASODKlPLVQEkt+mFMs+OqYkSZYruXQIE6pS9ezJtxYtRxPSDitvQ5tHeJASOjUyH3rqTCBWyWo0Dnc2WmiBs0mVRlghSI1BdxfJVkKur72cPJ54xKVAbkqjnQxaFR54QXCFtEyExNQLlye/3Gseb1NCn68cULqk+NPCRZwkjic6TIyuCEydQ5DLThOjudXXn9RZgOE6SoU70eb2Fx88n8OfPvxufo0gk+zbYIZOnI7Kfb6MUPBEjTl2U05dQqCJGFhJJfVJSzgO1QiaNsWUbAATsmJoocSCS5/lI7FdNex4YhzwdxEpWV3UcLxS/S9cKkMTJxalPQOg8Ksq4VNl8fhVvjzcC469tHeD1159p7dNBVpu2YVOGL4Qm9fVAFR9R76nfNnlwPr8KAPikPGtsFze3/lXf19Z9eLOHNcAjcW3rwFcfh1wbpCJiqAkK874wMWGTBwVxpoVB2WlbFrYwZBI/vNnzVw4SgaqUFwjzPp30DxMXOhtMfZg8nFpMtjlVkHhTsCIwjsCJIs2j5KQkoPOypMaSvS+KuIkD02G2B1vyhJCIogBtN+vyh9GTi1NtmyTVJ5XLif77UZF9b+YTPQsVMj5pCQ8EZHxgK5Hm2Kodsg29s1DtHKoeuLZ1IHsoW9m/SE6FJol+QmXEUxDt2HFymc7GkGe1H7JVNSqTZzTEEokTqHvJqGJA22+EE5k08qcBJIkBNXrdNplB0wihQDonIdTnHHnsRAcMhxxCVVh/Tuo3hDLb705xOtdBN2acMQo/vOYjzffGNlfFMQCA2u6qOIbWl2t39sOwDaxU6F2HIMhUR5EcRvwgYOAJFCRQJJrIGxY8SDI03hZGmu9xVRzzCFt9dgkA2Hg33OQBKW4jbhKqp9XEf+T1SB1mEgc+hNrkOFOOHHTEItA9mebiL2mD4sDkYTY5cpAx8CHUJjzKOXL12SU23n3cy5OXSPfgLX0MPIE2OU4Os7UmMIJunhwGDxz4HAj8v/eBt+KBSW5d5PBInbSINsOKgQ+hQHAfqNYNM4aCQNNZ57DvA/smMK3DcNt+G7+ac9ywkzgUIuZ+HzjAiLoPHDb8B/WrzKrxGASyAAAAAElFTkSuQmCC" alt="" />
<img id="t" src="tiles.png" alt="" />
